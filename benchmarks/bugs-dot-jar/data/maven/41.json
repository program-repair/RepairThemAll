{
    "bug_id": 41,
    "classification": {
        "singleLine": false
    },
    "commit": "806eaeb0",
    "failing_tests": [
        "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest"
    ],
    "files": 2,
    "jira_id": "1895",
    "linesAdd": 18,
    "linesRem": 19,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 0,
    "nb_test": 39,
    "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex b6d379ec2..108a976d1 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -137,18 +137,7 @@ private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVer\n                     VersionRange previousRange = previous.getArtifact().getVersionRange();\n                     VersionRange currentRange = node.getArtifact().getVersionRange();\n \n-                    // TODO: why do we force the version on it? what if they don't match?\n-                    if ( previousRange == null )\n-                    {\n-                        // version was already resolved\n-                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n-                    }\n-                    else if ( currentRange == null )\n-                    {\n-                        // version was already resolved\n-                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n-                    }\n-                    else\n+                    if ( previousRange != null && currentRange != null )\n                     {\n                         // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                         // version but the restriction is identical\n@@ -185,7 +174,8 @@ else if ( currentRange == null )\n \n                     // TODO: should this be part of mediation?\n                     // previous one is more dominant\n-                    ResolutionNode nearest, farthest;\n+                    ResolutionNode nearest;\n+                    ResolutionNode farthest;\n                     if ( previous.getDepth() <= node.getDepth() )\n                     {\n                         nearest = previous;\n@@ -197,11 +187,9 @@ else if ( currentRange == null )\n                         farthest = previous;\n                     }\n \n-                    /* if we need to update scope of nearest to use farthest scope */\n                     if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                     {\n-                        fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );\n-                        /* we need nearest version but farthest scope */\n+                        // if we need to update scope of nearest to use farthest scope, use the nearest version, but farthest scope\n                         nearest.disable();\n                         farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                     }\n@@ -321,13 +309,14 @@ else if ( currentRange == null )\n     }\n \n     /**\n-     * Check if the scope of the nearest needs to be updated with the scope of the farthest.\n+     * Check if the scope needs to be updated.\n      * <a href=\"http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info</a>.\n+     *\n      * @param farthest  farthest resolution node\n      * @param nearest   nearest resolution node\n      * @param listeners\n      */\n-    private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n+    boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n     {\n         boolean updateScope = false;\n         Artifact farthestArtifact = farthest.getArtifact();\n@@ -354,6 +343,16 @@ private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode neares\n             fireEvent( ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact );\n         }\n \n+        if ( updateScope )\n+        {\n+            fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact );\n+\n+            // previously we cloned the artifact, but it is more effecient to just update the scope\n+            // if problems are later discovered that the original object needs its original scope value, cloning may\n+            // again be appropriate\n+            nearestArtifact.setScope( farthestArtifact.getScope() );\n+        }\n+\n         return updateScope;\n     }\n \ndiff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\nindex 067e790f2..7d39bf961 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n@@ -219,7 +219,7 @@ public boolean filterTrail( ArtifactFilter filter )\n \n     public String toString()\n     {\n-        return artifact.toString() + \" (\" + depth + \")\";\n+        return artifact.toString() + \" (\" + depth + \"; \" + ( active ? \"enabled\" : \"disabled\" ) + \")\";\n     }\n \n }\n",
    "project": "maven"
}