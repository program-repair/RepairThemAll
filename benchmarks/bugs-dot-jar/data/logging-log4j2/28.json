{
    "bug_id": 28,
    "classification": {
        "singleLine": false
    },
    "commit": "a5a1f1a2",
    "failing_tests": [
        "org.apache.logging.log4j.core.async.AsyncLoggerConfigUseAfterShutdownTest",
        "org.apache.logging.log4j.core.async.AsyncLoggerUseAfterShutdownTest"
    ],
    "files": 2,
    "jira_id": "639",
    "linesAdd": 29,
    "linesRem": 2,
    "nb_error": 2,
    "nb_failure": 0,
    "nb_skipped": 2,
    "nb_test": 565,
    "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\nindex b99608c20..c8329732d 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n@@ -231,9 +231,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n             threadlocalInfo.set(info);\n         }\n         \n+        Disruptor<RingBufferLogEvent> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return;\n+        }\n+\n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n-        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+        if (info.isAppenderThread && temp.getRingBuffer().remainingCapacity() == 0) {\n             // bypass RingBuffer and invoke Appender directly\n             config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n             return;\n@@ -266,7 +272,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n                 // CachedClock: 10% faster than system clock, smaller gaps\n                 clock.currentTimeMillis());\n \n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.publishEvent(info.translator);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n     }\n \n     private static StackTraceElement location(final String fqcnOfLogger) {\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\nindex 9d2f4f06f..2e8814c06 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n@@ -316,16 +316,29 @@ public void run() {\n      *          calling thread needs to process the event itself\n      */\n     public boolean callAppendersFromAnotherThread(final LogEvent event) {\n+        Disruptor<Log4jEventWrapper> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return true;\n+        }\n \n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n         if (isAppenderThread.get() == Boolean.TRUE //\n-                && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+                && temp.getRingBuffer().remainingCapacity() == 0) {\n \n             // bypass RingBuffer and invoke Appender directly\n             return false;\n         }\n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n         return true;\n     }\n \n",
    "project": "logging-log4j2"
}