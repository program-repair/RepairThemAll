{
    "bug_id": 74,
    "classification": {
        "singleLine": false
    },
    "commit": "0c20bfd8",
    "failing_tests": [
        "org.apache.logging.log4j.core.config.plugins.util.ResolverUtilTest"
    ],
    "files": 1,
    "jira_id": "1008",
    "linesAdd": 104,
    "linesRem": 79,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 2,
    "nb_test": 745,
    "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\nindex 475ef9cd3..65da5bca3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.net.URLDecoder;\n import java.util.Arrays;\n@@ -41,26 +42,29 @@\n import org.osgi.framework.wiring.BundleWiring;\n \n /**\n- * <p>ResolverUtil is used to locate classes that are available in the/a class path and meet\n- * arbitrary conditions. The two most common conditions are that a class implements/extends\n- * another class, or that is it annotated with a specific annotation. However, through the use\n- * of the {@link Test} class it is possible to search using arbitrary conditions.</p>\n+ * <p>\n+ * ResolverUtil is used to locate classes that are available in the/a class path and meet arbitrary conditions. The two\n+ * most common conditions are that a class implements/extends another class, or that is it annotated with a specific\n+ * annotation. However, through the use of the {@link Test} class it is possible to search using arbitrary conditions.\n+ * </p>\n  *\n- * <p>A ClassLoader is used to locate all locations (directories and jar files) in the class\n- * path that contain classes within certain packages, and then to load those classes and\n- * check them. By default the ClassLoader returned by\n- *  {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden\n- * by calling {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()}\n- * methods.</p>\n+ * <p>\n+ * A ClassLoader is used to locate all locations (directories and jar files) in the class path that contain classes\n+ * within certain packages, and then to load those classes and check them. By default the ClassLoader returned by\n+ * {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden by calling\n+ * {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()} methods.\n+ * </p>\n  *\n- * <p>General searches are initiated by calling the\n- * {@link #find(ResolverUtil.Test, String...)} method and supplying\n- * a package name and a Test instance. This will cause the named package <b>and all sub-packages</b>\n- * to be scanned for classes that meet the test. There are also utility methods for the common\n- * use cases of scanning multiple packages for extensions of particular classes, or classes\n- * annotated with a specific annotation.</p>\n+ * <p>\n+ * General searches are initiated by calling the {@link #find(ResolverUtil.Test, String...)} method and supplying a\n+ * package name and a Test instance. This will cause the named package <b>and all sub-packages</b> to be scanned for\n+ * classes that meet the test. There are also utility methods for the common use cases of scanning multiple packages for\n+ * extensions of particular classes, or classes annotated with a specific annotation.\n+ * </p>\n  *\n- * <p>The standard usage pattern for the ResolverUtil class is as follows:</p>\n+ * <p>\n+ * The standard usage pattern for the ResolverUtil class is as follows:\n+ * </p>\n  *\n  * <pre>\n  * ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();\n@@ -70,7 +74,8 @@\n  * Collection&lt;ActionBean&gt; beans = resolver.getClasses();\n  * </pre>\n  *\n- * <p>This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n+ * <p>\n+ * This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n  * </p>\n  */\n public class ResolverUtil {\n@@ -88,14 +93,14 @@\n     private final Set<URI> resourceMatches = new HashSet<URI>();\n \n     /**\n-     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned\n-     * by Thread.currentThread().getContextClassLoader() will be used.\n+     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned by\n+     * Thread.currentThread().getContextClassLoader() will be used.\n      */\n     private ClassLoader classloader;\n \n     /**\n-     * Provides access to the classes discovered so far. If no calls have been made to\n-     * any of the {@code find()} methods, this set will be empty.\n+     * Provides access to the classes discovered so far. If no calls have been made to any of the {@code find()}\n+     * methods, this set will be empty.\n      *\n      * @return the set of classes that have been discovered.\n      */\n@@ -105,16 +110,16 @@\n \n     /**\n      * Returns the matching resources.\n+     * \n      * @return A Set of URIs that match the criteria.\n      */\n     public Set<URI> getResources() {\n         return resourceMatches;\n     }\n \n-\n     /**\n-     * Returns the classloader that will be used for scanning for classes. If no explicit\n-     * ClassLoader has been set by the calling, the context class loader will be used.\n+     * Returns the classloader that will be used for scanning for classes. If no explicit ClassLoader has been set by\n+     * the calling, the context class loader will be used.\n      *\n      * @return the ClassLoader that will be used to scan for classes\n      */\n@@ -123,19 +128,24 @@ public ClassLoader getClassLoader() {\n     }\n \n     /**\n-     * Sets an explicit ClassLoader that should be used when scanning for classes. If none\n-     * is set then the context classloader will be used.\n+     * Sets an explicit ClassLoader that should be used when scanning for classes. If none is set then the context\n+     * classloader will be used.\n      *\n-     * @param classloader a ClassLoader to use when scanning for classes\n+     * @param classloader\n+     *        a ClassLoader to use when scanning for classes\n      */\n-    public void setClassLoader(final ClassLoader classloader) { this.classloader = classloader; }\n+    public void setClassLoader(final ClassLoader classloader) {\n+        this.classloader = classloader;\n+    }\n \n     /**\n-     * Attempts to discover classes that pass the test. Accumulated\n-     * classes can be accessed by calling {@link #getClasses()}.\n+     * Attempts to discover classes that pass the test. Accumulated classes can be accessed by calling\n+     * {@link #getClasses()}.\n      *\n-     * @param test the test to determine matching classes\n-     * @param packageNames one or more package names to scan (including subpackages) for classes\n+     * @param test\n+     *        the test to determine matching classes\n+     * @param packageNames\n+     *        one or more package names to scan (including subpackages) for classes\n      */\n     public void find(final Test test, final String... packageNames) {\n         if (packageNames == null) {\n@@ -148,14 +158,14 @@ public void find(final Test test, final String... packageNames) {\n     }\n \n     /**\n-     * Scans for classes starting at the package provided and descending into subpackages.\n-     * Each class is offered up to the Test as it is discovered, and if the Test returns\n-     * true the class is retained.  Accumulated classes can be fetched by calling\n-     * {@link #getClasses()}.\n+     * Scans for classes starting at the package provided and descending into subpackages. Each class is offered up to\n+     * the Test as it is discovered, and if the Test returns true the class is retained. Accumulated classes can be\n+     * fetched by calling {@link #getClasses()}.\n      *\n-     * @param test an instance of {@link Test} that will be used to filter classes\n-     * @param packageName the name of the package from which to start scanning for\n-     *        classes, e.g. {@code net.sourceforge.stripes}\n+     * @param test\n+     *        an instance of {@link Test} that will be used to filter classes\n+     * @param packageName\n+     *        the name of the package from which to start scanning for classes, e.g. {@code net.sourceforge.stripes}\n      */\n     public void findInPackage(final Test test, String packageName) {\n         packageName = packageName.replace('.', '/');\n@@ -198,11 +208,13 @@ public void findInPackage(final Test test, String packageName) {\n                 }\n             } catch (final IOException ioe) {\n                 LOGGER.warn(\"could not read entries\", ioe);\n+            } catch (URISyntaxException e) {\n+                LOGGER.warn(\"could not read entries\", e);\n             }\n         }\n     }\n \n-    String extractPath(final URL url) throws UnsupportedEncodingException {\n+    String extractPath(final URL url) throws UnsupportedEncodingException, URISyntaxException {\n         String urlPath = url.getPath(); // same as getFile but without the Query portion\n         // System.out.println(url.getProtocol() + \"->\" + urlPath);\n \n@@ -226,9 +238,10 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n         if (neverDecode.contains(protocol)) {\n             return urlPath;\n         }\n-        if (new File(urlPath).exists()) {\n+        final String cleanPath = new URI(urlPath).getPath();\n+        if (new File(cleanPath).exists()) {\n             // if URL-encoded file exists, don't decode it\n-            return urlPath;\n+            return cleanPath;\n         }\n         urlPath = URLDecoder.decode(urlPath, Constants.UTF_8.name());\n         return urlPath;\n@@ -237,8 +250,8 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n     private void loadImplementationsInBundle(final Test test, final String packageName) {\n         // Do not remove the cast on the next line as removing it will cause a compile error on Java 7.\n         @SuppressWarnings(\"RedundantCast\")\n-        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(\n-                ResolverUtil.class).adapt(BundleWiring.class);\n+        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(ResolverUtil.class)\n+                .adapt(BundleWiring.class);\n         @SuppressWarnings(\"unchecked\")\n         final Collection<String> list = (Collection<String>) wiring.listResources(packageName, \"*.class\",\n                 BundleWiring.LISTRESOURCES_RECURSE);\n@@ -247,18 +260,20 @@ private void loadImplementationsInBundle(final Test test, final String packageNa\n         }\n     }\n \n-\n     /**\n-     * Finds matches in a physical directory on a filesystem.  Examines all\n-     * files within a directory - if the File object is not a directory, and ends with <i>.class</i>\n-     * the file is loaded and tested to see if it is acceptable according to the Test.  Operates\n-     * recursively to find classes within a folder structure matching the package structure.\n+     * Finds matches in a physical directory on a filesystem. Examines all files within a directory - if the File object\n+     * is not a directory, and ends with <i>.class</i> the file is loaded and tested to see if it is acceptable\n+     * according to the Test. Operates recursively to find classes within a folder structure matching the package\n+     * structure.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the package name up to this directory in the package hierarchy.  E.g. if\n-     *        /classes is in the classpath and we wish to examine files in /classes/org/apache then\n-     *        the values of <i>parent</i> would be <i>org/apache</i>\n-     * @param location a File object representing a directory\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the package name up to this directory in the package hierarchy. E.g. if /classes is in the classpath and\n+     *        we wish to examine files in /classes/org/apache then the values of <i>parent</i> would be\n+     *        <i>org/apache</i>\n+     * @param location\n+     *        a File object representing a directory\n      */\n     private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {\n         final File[] files = location.listFiles();\n@@ -285,13 +300,15 @@ private boolean isTestApplicable(final Test test, final String path) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param jarFile the jar file to be examined for classes\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param jarFile\n+     *        the jar file to be examined for classes\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final File jarFile) {\n         @SuppressWarnings(\"resource\")\n@@ -325,13 +342,15 @@ private void close(final JarInputStream jarStream, final Object source) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param stream The jar InputStream\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param stream\n+     *        The jar InputStream\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final String path,\n             final JarInputStream stream) {\n@@ -346,17 +365,19 @@ private void loadImplementationsInJar(final Test test, final String parent, fina\n                 }\n             }\n         } catch (final IOException ioe) {\n-            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" +\n-                test + \" due to an IOException\", ioe);\n+            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test\n+                    + \" due to an IOException\", ioe);\n         }\n     }\n \n     /**\n-     * Add the class designated by the fully qualified class name provided to the set of\n-     * resolved classes if and only if it is approved by the Test supplied.\n+     * Add the class designated by the fully qualified class name provided to the set of resolved classes if and only if\n+     * it is approved by the Test supplied.\n      *\n-     * @param test the test used to determine if the class matches\n-     * @param fqn the fully qualified name of a class\n+     * @param test\n+     *        the test used to determine if the class matches\n+     * @param fqn\n+     *        the fully qualified name of a class\n      */\n     protected void addIfMatching(final Test test, final String fqn) {\n         try {\n@@ -387,21 +408,25 @@ protected void addIfMatching(final Test test, final String fqn) {\n     }\n \n     /**\n-     * A simple interface that specifies how to test classes to determine if they\n-     * are to be included in the results produced by the ResolverUtil.\n+     * A simple interface that specifies how to test classes to determine if they are to be included in the results\n+     * produced by the ResolverUtil.\n      */\n     public interface Test {\n         /**\n-         * Will be called repeatedly with candidate classes. Must return True if a class\n-         * is to be included in the results, false otherwise.\n-         * @param type The Class to match against.\n+         * Will be called repeatedly with candidate classes. Must return True if a class is to be included in the\n+         * results, false otherwise.\n+         * \n+         * @param type\n+         *        The Class to match against.\n          * @return true if the Class matches.\n          */\n         boolean matches(Class<?> type);\n \n         /**\n          * Test for a resource.\n-         * @param resource The URI to the resource.\n+         * \n+         * @param resource\n+         *        The URI to the resource.\n          * @return true if the resource matches.\n          */\n         boolean matches(URI resource);\n",
    "project": "logging-log4j2",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}