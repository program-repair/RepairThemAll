{
    "bug_id": 6,
    "classification": {
        "singleLine": false
    },
    "commit": "39d526e6",
    "failing_tests": [
        "org.apache.flink.types.parser.ByteValueParserTest",
        "org.apache.flink.types.parser.LongParserTest",
        "org.apache.flink.types.parser.IntParserTest",
        "org.apache.flink.types.parser.DoubleParserTest",
        "org.apache.flink.types.parser.ShortParserTest",
        "org.apache.flink.types.parser.FloatValueParserTest",
        "org.apache.flink.types.parser.FloatParserTest",
        "org.apache.flink.types.parser.DoubleValueParserTest",
        "org.apache.flink.types.parser.LongValueParserTest",
        "org.apache.flink.types.parser.ByteParserTest",
        "org.apache.flink.types.parser.ShortValueParserTest",
        "org.apache.flink.types.parser.IntValueParserTest"
    ],
    "files": 13,
    "jira_id": "1820",
    "linesAdd": 116,
    "linesRem": 59,
    "nb_error": 0,
    "nb_failure": 18,
    "nb_skipped": 0,
    "nb_test": 835,
    "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\nindex 5858da2d1f..09e517a33f 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n@@ -36,7 +36,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -44,6 +45,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (byte) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -75,38 +80,35 @@ public Byte getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -121,7 +123,7 @@ public static final byte parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (byte) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\nindex f9b36e4131..612a1cb381 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n@@ -52,6 +52,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\tfor (int i = startPos; i < limit; i++) {\n \n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((byte) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\nindex 947fdfe656..086c1f5077 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n@@ -42,11 +42,15 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tthis.result = Double.parseDouble(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -63,33 +67,33 @@ public Double getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -102,7 +106,12 @@ public static final double parseField(byte[] bytes, int startPos, int length, ch\n \t\t\ti++;\n \t\t}\n \n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n \t\treturn Double.parseDouble(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\nindex e225c1f583..7751831cbe 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tdouble value = Double.parseDouble(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\nindex 33697fda4c..55e991586b 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n@@ -64,7 +64,13 @@\n \t\tUNTERMINATED_QUOTED_STRING,\n \n \t\t/** The parser found characters between the end of the quoted string and the delimiter. */\n-\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING\n+\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING,\n+\t\t\n+\t\t/** The string is empty. */\n+\t\tEMPTY_STRING,\n+\n+\t\t/** There is whitespace in a numeric field. */\n+\t\tWHITESPACE_IN_NUMERIC_FIELD\n \t}\n \t\n \tprivate ParseErrorState errorState = ParseErrorState.NONE;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\nindex 7d166c7ebe..be98aa1a78 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n@@ -27,7 +27,8 @@\n \tprivate float result;\n \t\n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float \n+\t\treusable) {\n \n \t\tint i = startPos;\n \n@@ -40,12 +41,17 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t\ti++;\n \t\t}\n \n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n \t\ttry {\n \t\t\tthis.result = Float.parseFloat(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -62,33 +68,33 @@ public Float getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -101,7 +107,12 @@ public static final float parseField(byte[] bytes, int startPos, int length, cha\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n+\t\tint len = str.length();\n \t\treturn Float.parseFloat(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\nindex af16d4c106..e8caac2979 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tfloat value = Float.parseFloat(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\nindex c871f4a7cb..dcd2ec25c4 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n@@ -32,7 +32,8 @@\n \tprivate int result;\n \n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer \n+\t\treusable) {\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -43,7 +44,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || ( startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -51,6 +53,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (int) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -82,38 +88,35 @@ public Integer getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +131,7 @@ public static final int parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (int) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\nindex 8cb8176827..abd8615650 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((int) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\nindex af17f15578..bb6c7c9370 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n@@ -47,6 +47,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = neg ? -val : val;\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -123,9 +127,6 @@ public static final long parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -140,7 +141,7 @@ public static final long parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn neg ? -val : val;\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\nindex 8b697ccbb7..a99a86e2ca 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue(neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\nindex a6f98984fc..6e04d60a2d 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (short) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -111,9 +115,6 @@ public static final short parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +129,7 @@ public static final short parseField(byte[] bytes, int startPos, int length, cha\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (short) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\nindex f5168cc402..4289d1a934 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((short) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n",
    "project": "flink"
}