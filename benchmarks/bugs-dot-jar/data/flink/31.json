{
    "bug_id": 31,
    "classification": {
        "singleLine": false
    },
    "commit": "63d9800e",
    "failing_tests": [
        "org.apache.flink.streaming.api.state.StatefulOperatorTest"
    ],
    "files": 2,
    "jira_id": "2713",
    "linesAdd": 58,
    "linesRem": 8,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 1,
    "nb_test": 242,
    "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\nindex 115a97c71f..408a0f0323 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n@@ -55,6 +55,8 @@\n \tprivate IN currentInput;\n \n \tprivate ClassLoader cl;\n+\tprivate boolean restored = true;\n+\tprivate StateHandle<Serializable> checkpoint = null;\n \n \tpublic PartitionedStreamOperatorState(StateCheckpointer<S, C> checkpointer,\n \t\t\tStateHandleProvider<C> provider, KeySelector<IN, Serializable> keySelector, ClassLoader cl) {\n@@ -76,6 +78,10 @@ public S value() throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for accessing the state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -100,6 +106,10 @@ public void update(S state) throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for updating a state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -131,12 +141,26 @@ public void setCurrentInput(IN input) {\n \n \t@Override\n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n-\t\treturn stateStore.snapshotStates(checkpointId, checkpointTimestamp);\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn restored ? stateStore.snapshotStates(checkpointId, checkpointTimestamp) : provider\n+\t\t\t\t.createStateHandle(checkpoint.getState(cl));\n \t}\n \t\n \t@Override\n-\tpublic void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tstateStore.restoreStates(snapshots, userCodeClassLoader);\n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We store the snapshot for lazy restore\n+\t\tcheckpoint = snapshot;\n+\t\trestored = false;\n+\t}\n+\t\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\ttry {\n+\t\t\tstateStore.restoreStates(checkpoint, cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \t@Override\n@@ -144,6 +168,12 @@ public void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCo\n \t\treturn stateStore.getPartitionedState();\n \t}\n \t\n+\t@Override\n+\tpublic void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n+\t\tsuper.setCheckpointer(checkpointer);\n+\t\tstateStore.setCheckPointer(checkpointer);\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn stateStore.toString();\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\nindex 29a19b58ec..c33b94ea26 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n@@ -44,7 +44,10 @@\n \n \tprivate S state;\n \tprotected StateCheckpointer<S, C> checkpointer;\n-\tprivate final StateHandleProvider<Serializable> provider;\n+\tprotected final StateHandleProvider<Serializable> provider;\n+\t\n+\tprivate boolean restored = true;\n+\tprivate Serializable checkpoint = null;\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic StreamOperatorState(StateCheckpointer<S, C> checkpointer, StateHandleProvider<C> provider) {\n@@ -59,6 +62,10 @@ public StreamOperatorState(StateHandleProvider<C> provider) {\n \n \t@Override\n \tpublic S value() throws IOException {\n+\t\tif (!restored) {\n+\t\t\t// If the state is not restore it yet, restore at this point\n+\t\t\trestoreWithCheckpointer();\n+\t\t}\n \t\treturn state;\n \t}\n \n@@ -67,6 +74,11 @@ public void update(S state) throws IOException {\n \t\tif (state == null) {\n \t\t\tthrow new RuntimeException(\"Cannot set state to null.\");\n \t\t}\n+\t\tif (!restored) {\n+\t\t\t// If the value is updated before the restore it is overwritten\n+\t\t\trestored = true;\n+\t\t\tcheckpoint = false;\n+\t\t}\n \t\tthis.state = state;\n \t}\n \t\n@@ -90,14 +102,22 @@ public void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n \n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp)\n \t\t\tthrows Exception {\n-\t\treturn provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId,\n-\t\t\t\tcheckpointTimestamp));\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn provider.createStateHandle(restored ? checkpointer.snapshotState(value(), checkpointId,\n+\t\t\t\tcheckpointTimestamp) : checkpoint);\n+\t}\n \n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We set the checkpoint for lazy restore\n+\t\tcheckpoint = snapshot.getState(userCodeClassLoader);\n+\t\trestored = false;\n \t}\n \t\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tupdate(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\tupdate(checkpointer.restoreState((C) checkpoint));\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \tpublic Map<Serializable, S> getPartitionedState() throws Exception {\n",
    "project": "flink"
}