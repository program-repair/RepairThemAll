{
    "bug_id": 30,
    "classification": {
        "singleLine": false
    },
    "commit": "30761572",
    "failing_tests": [
        "operators.KeysTest"
    ],
    "files": 2,
    "jira_id": "2442",
    "linesAdd": 21,
    "linesRem": 41,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 0,
    "nb_test": 962,
    "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\nindex 69d306f891..09874e5d5e 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n@@ -223,41 +223,41 @@ public ExpressionKeys(int[] groupingFields, TypeInformation<T> type, boolean all\n \t\t\t} else {\n \t\t\t\tgroupingFields = rangeCheckFields(groupingFields, type.getArity() -1);\n \t\t\t}\n-\t\t\tCompositeType<?> compositeType = (CompositeType<?>) type;\n \t\t\tPreconditions.checkArgument(groupingFields.length > 0, \"Grouping fields can not be empty at this point\");\n \t\t\t\n \t\t\tkeyFields = new ArrayList<FlatFieldDescriptor>(type.getTotalFields());\n \t\t\t// for each key, find the field:\n \t\t\tfor(int j = 0; j < groupingFields.length; j++) {\n+\t\t\t\tint keyPos = groupingFields[j];\n+\n+\t\t\t\tint offset = 0;\n \t\t\t\tfor(int i = 0; i < type.getArity(); i++) {\n-\t\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n \n-\t\t\t\t\tif(groupingFields[j] == i) { // check if user set the key\n-\t\t\t\t\t\tint keyId = countNestedElementsBefore(compositeType, i) + i;\n-\t\t\t\t\t\tif(fieldType instanceof TupleTypeInfoBase) {\n-\t\t\t\t\t\t\tTupleTypeInfoBase<?> tupleFieldType = (TupleTypeInfoBase<?>) fieldType;\n-\t\t\t\t\t\t\ttupleFieldType.addAllFields(keyId, keyFields);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tPreconditions.checkArgument(fieldType instanceof AtomicType, \"Wrong field type\");\n-\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(keyId, fieldType));\n+\t\t\t\t\tTypeInformation fieldType = ((CompositeType<?>) type).getTypeAt(i);\n+\t\t\t\t\tif(i < keyPos) {\n+\t\t\t\t\t\t// not yet there, increment key offset\n+\t\t\t\t\t\toffset += fieldType.getTotalFields();\n \t\t\t\t\t}\n-\t\t\t\t\t\t\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// arrived at key position\n+\t\t\t\t\t\tif(fieldType instanceof CompositeType) {\n+\t\t\t\t\t\t\t// add all nested fields of composite type\n+\t\t\t\t\t\t\t((CompositeType) fieldType).getFlatFields(\"*\", offset, keyFields);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse if(fieldType instanceof AtomicType) {\n+\t\t\t\t\t\t\t// add atomic type field\n+\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(offset, fieldType));\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t// type should either be composite or atomic\n+\t\t\t\t\t\t\tthrow new InvalidProgramException(\"Field type is neither CompositeType nor AtomicType: \"+fieldType);\n \t\t\t\t\t\t}\n-\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n+\t\t\t\t\t\t// go to next key\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\n-\t\tprivate static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {\n-\t\t\tif( pos == 0) {\n-\t\t\t\treturn 0;\n \t\t\t\t}\n-\t\t\tint ret = 0;\n-\t\t\tfor (int i = 0; i < pos; i++) {\n-\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n-\t\t\t\tret += fieldType.getTotalFields() -1;\n \t\t\t}\n-\t\t\treturn ret;\n+\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n \t\t}\n \n \t\tpublic static <R> List<R> removeNullElementsFromList(List<R> in) {\ndiff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\nindex 3314ca9ae4..881e690d5c 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n@@ -23,7 +23,6 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.flink.api.common.typeinfo.AtomicType;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.CompositeType;\n import org.apache.flink.api.java.operators.Keys.ExpressionKeys;\n@@ -88,25 +87,6 @@ public int getTotalFields() {\n \t\treturn tupleType;\n \t}\n \n-\t/**\n-\t * Recursively add all fields in this tuple type. We need this in particular to get all\n-\t * the types.\n-\t * @param startKeyId\n-\t * @param keyFields\n-\t */\n-\tpublic void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {\n-\t\tfor(int i = 0; i < this.getArity(); i++) {\n-\t\t\tTypeInformation<?> type = this.types[i];\n-\t\t\tif(type instanceof AtomicType) {\n-\t\t\t\tkeyFields.add(new FlatFieldDescriptor(startKeyId, type));\n-\t\t\t} else if(type instanceof TupleTypeInfoBase<?>) {\n-\t\t\t\tTupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;\n-\t\t\t\tttb.addAllFields(startKeyId, keyFields);\n-\t\t\t}\n-\t\t\tstartKeyId += type.getTotalFields();\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result) {\n \n",
    "project": "flink",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}