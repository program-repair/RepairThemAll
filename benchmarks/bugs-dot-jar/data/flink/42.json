{
    "bug_id": 42,
    "classification": {
        "singleLine": false
    },
    "commit": "8f321c72",
    "failing_tests": [
        "org.apache.flink.api.common.io.FileOutputFormatTest",
        "org.apache.flink.core.fs.PathTest"
    ],
    "files": 1,
    "jira_id": "1640",
    "linesAdd": 24,
    "linesRem": 13,
    "nb_error": 0,
    "nb_failure": 8,
    "nb_skipped": 0,
    "nb_test": 819,
    "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\nindex a104d86a90..30a2a65394 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n@@ -37,6 +37,8 @@\n /**\n  * Names a file or directory in a {@link FileSystem}. Path strings use slash as\n  * the directory separator. A path string is absolute if it begins with a slash.\n+ *\n+ * Tailing slashes are removed from the path.\n  */\n public class Path implements IOReadableWritable, Serializable {\n \t\n@@ -71,7 +73,7 @@ public Path() {}\n \t * Constructs a path object from a given URI.\n \t * \n \t * @param uri\n-\t *        the URI to contruct the path object from\n+\t *        the URI to construct the path object from\n \t */\n \tpublic Path(URI uri) {\n \t\tthis.uri = uri;\n@@ -145,18 +147,22 @@ public Path(Path parent, Path child) {\n \t/**\n  \t * Checks if the provided path string is either null or has zero length and throws\n \t * a {@link IllegalArgumentException} if any of the two conditions apply.\n+\t * In addition, leading and tailing whitespaces are removed.\n \t *\n \t * @param path\n \t *        the path string to be checked\n+\t * @return The checked and trimmed path.\n \t */\n-\tprivate void checkPathArg(String path) {\n+\tprivate String checkAndTrimPathArg(String path) {\n \t\t// disallow construction of a Path from an empty string\n \t\tif (path == null) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from a null string\");\n \t\t}\n+\t\tpath = path.trim();\n \t\tif (path.length() == 0) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from an empty string\");\n \t\t}\n+\t\treturn path;\n \t}\n \n \t/**\n@@ -167,7 +173,7 @@ private void checkPathArg(String path) {\n \t *        the string to construct a path from\n \t */\n \tpublic Path(String pathString) {\n-\t\tcheckPathArg(pathString);\n+\t\tpathString = checkAndTrimPathArg(pathString);\n \n \t\t// We can't use 'new URI(String)' directly, since it assumes things are\n \t\t// escaped, which we don't require of Paths.\n@@ -217,7 +223,7 @@ public Path(String pathString) {\n \t *        the path string\n \t */\n \tpublic Path(String scheme, String authority, String path) {\n-\t\tcheckPathArg(path);\n+\t\tpath = checkAndTrimPathArg(path);\n \t\tinitialize(scheme, authority, path);\n \t}\n \n@@ -247,9 +253,18 @@ private void initialize(String scheme, String authority, String path) {\n \t * @return the normalized path string\n \t */\n \tprivate String normalizePath(String path) {\n-\t\t// remove double slashes & backslashes\n-\t\tpath = path.replace(\"//\", \"/\");\n+\n+\t\t// remove leading and tailing whitespaces\n+\t\tpath = path.trim();\n+\n+\t\t// remove consecutive slashes & backslashes\n \t\tpath = path.replace(\"\\\\\", \"/\");\n+\t\tpath = path.replaceAll(\"/+\", \"/\");\n+\n+\t\t// remove tailing separator\n+\t\tif(!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\n+\t\t\tpath = path.substring(0, path.length() - SEPARATOR.length());\n+\t\t}\n \n \t\treturn path;\n \t}\n@@ -306,23 +321,19 @@ public boolean isAbsolute() {\n \t}\n \n \t/**\n-\t * Returns the final component of this path.\n+\t * Returns the final component of this path, i.e., everything that follows the last separator.\n \t * \n \t * @return the final component of the path\n \t */\n \tpublic String getName() {\n \t\tfinal String path = uri.getPath();\n-\t\tif (path.endsWith(SEPARATOR)) {\n-\t\t\tfinal int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\n-\t\t\treturn path.substring(slash + 1, path.length() - SEPARATOR.length());\n-\t\t} else {\n \t\tfinal int slash = path.lastIndexOf(SEPARATOR);\n \t\treturn path.substring(slash + 1);\n \t}\n-\t}\n \n \t/**\n-\t * Returns the parent of a path or <code>null</code> if at root.\n+\t * Returns the parent of a path, i.e., everything that precedes the last separator\n+\t * or <code>null</code> if at root.\n \t * \n \t * @return the parent of a path or <code>null</code> if at root.\n \t */\n",
    "project": "flink",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}