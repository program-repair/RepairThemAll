{
    "bug_id": 60,
    "classification": {
        "singleLine": false
    },
    "commit": "dc9f23d9",
    "failing_tests": [
        "org.apache.accumulo.core.iterators.user.FilterTest"
    ],
    "files": 1,
    "jira_id": "776",
    "linesAdd": 54,
    "linesRem": 19,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 0,
    "nb_test": 295,
    "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\nindex 2dbfe66fd..49f0146e4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n@@ -17,8 +17,8 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.Date;\n import java.util.Map;\n import java.util.TimeZone;\n \n@@ -33,6 +33,7 @@\n  * A Filter that matches entries whose timestamps fall within a range.\n  */\n public class TimestampFilter extends Filter {\n+  private static final String LONG_PREFIX = \"LONG\";\n   private final SimpleDateFormat dateParser = initDateParser();\n   \n   private static SimpleDateFormat initDateParser() {\n@@ -86,10 +87,20 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n       throw new IllegalArgumentException(\"must have either start or end for \" + TimestampFilter.class.getName());\n     \n     try {\n-      if (hasStart)\n-        start = dateParser.parse(options.get(START)).getTime();\n-      if (hasEnd)\n-        end = dateParser.parse(options.get(END)).getTime();\n+      if (hasStart) {\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          start = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          start = dateParser.parse(s).getTime();\n+      }\n+      if (hasEnd) {\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          end = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          end = dateParser.parse(s).getTime();\n+      }\n     } catch (Exception e) {\n       throw new IllegalArgumentException(e);\n     }\n@@ -116,8 +127,8 @@ public IteratorOptions describeOptions() {\n     IteratorOptions io = super.describeOptions();\n     io.setName(\"tsfilter\");\n     io.setDescription(\"TimestampFilter displays entries with timestamps between specified values\");\n-    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz)\");\n-    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz)\");\n+    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n+    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n     io.addNamedOption(\"startInclusive\", \"true or false\");\n     io.addNamedOption(\"endInclusive\", \"true or false\");\n     return io;\n@@ -126,11 +137,27 @@ public IteratorOptions describeOptions() {\n   @Override\n   public boolean validateOptions(Map<String,String> options) {\n     super.validateOptions(options);\n+    boolean hasStart = false;\n+    boolean hasEnd = false;\n     try {\n-      if (options.containsKey(START))\n-        dateParser.parse(options.get(START));\n-      if (options.containsKey(END))\n-        dateParser.parse(options.get(END));\n+      if (options.containsKey(START)) {\n+        hasStart = true;\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (options.containsKey(END)) {\n+        hasEnd = true;\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (!hasStart && !hasEnd)\n+        return false;\n       if (options.get(START_INCL) != null)\n         Boolean.parseBoolean(options.get(START_INCL));\n       if (options.get(END_INCL) != null)\n@@ -185,8 +212,13 @@ public static void setRange(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, String start, boolean startInclusive) {\n-    is.addOption(START, start);\n-    is.addOption(START_INCL, Boolean.toString(startInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long startTS = dateParser.parse(start).getTime();\n+      setStart(is, startTS, startInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + start);\n+    }\n   }\n   \n   /**\n@@ -200,8 +232,13 @@ public static void setStart(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n-    is.addOption(END, end);\n-    is.addOption(END_INCL, Boolean.toString(endInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long endTS = dateParser.parse(end).getTime();\n+      setEnd(is, endTS, endInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + end);\n+    }\n   }\n   \n   /**\n@@ -248,8 +285,7 @@ public static void setRange(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, long start, boolean startInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(START, dateParser.format(new Date(start)));\n+    is.addOption(START, LONG_PREFIX + Long.toString(start));\n     is.addOption(START_INCL, Boolean.toString(startInclusive));\n   }\n   \n@@ -264,8 +300,7 @@ public static void setStart(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, long end, boolean endInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(END, dateParser.format(new Date(end)));\n+    is.addOption(END, LONG_PREFIX + Long.toString(end));\n     is.addOption(END_INCL, Boolean.toString(endInclusive));\n   }\n }\n",
    "project": "accumulo"
}