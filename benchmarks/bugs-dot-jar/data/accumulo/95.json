{
    "bug_id": 95,
    "classification": {
        "singleLine": false
    },
    "commit": "397f86f6",
    "failing_tests": [
        "org.apache.accumulo.core.iterators.user.RegExFilterTest"
    ],
    "files": 1,
    "jira_id": "209",
    "linesAdd": 47,
    "linesRem": 10,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 0,
    "nb_test": 279,
    "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex 0b3b73f11..86b2bde43 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -28,7 +29,6 @@\n import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.ByteArrayBackedCharSequence;\n \n /**\n  * A Filter that matches entries based on Java regular expressions.\n@@ -52,6 +52,9 @@\n   public static final String COLQ_REGEX = \"colqRegex\";\n   public static final String VALUE_REGEX = \"valueRegex\";\n   public static final String OR_FIELDS = \"orFields\";\n+  public static final String ENCODING = \"encoding\";\n+  \n+  public static final String ENCODING_DEFAULT = \"UTF-8\";\n   \n   private Matcher rowMatcher;\n   private Matcher colfMatcher;\n@@ -59,10 +62,9 @@\n   private Matcher valueMatcher;\n   private boolean orFields = false;\n   \n-  private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n+  private String encoding = ENCODING_DEFAULT;\n   \n-  private Matcher copyMatcher(Matcher m)\n-  {\n+  private Matcher copyMatcher(Matcher m) {\n     if (m == null)\n       return m;\n     else\n@@ -71,21 +73,25 @@ private Matcher copyMatcher(Matcher m)\n   \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n-      babcs.set(bs);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(bs.getBackingArray(), encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n   private boolean matches(Matcher matcher, byte data[], int offset, int len) {\n     if (matcher != null) {\n-      babcs.set(data, offset, len);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(data, offset, len, encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n@@ -130,6 +136,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     } else {\n       orFields = false;\n     }\n+    \n+    if (options.containsKey(ENCODING)) {\n+      encoding = options.get(ENCODING);\n+    }\n   }\n   \n   @Override\n@@ -142,6 +152,7 @@ public IteratorOptions describeOptions() {\n     io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\n     io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\n     io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\n+    io.addNamedOption(RegExFilter.ENCODING, \"character encoding of byte array value (default is \" + ENCODING_DEFAULT + \")\");\n     return io;\n   }\n   \n@@ -160,6 +171,17 @@ public boolean validateOptions(Map<String,String> options) {\n     if (options.containsKey(VALUE_REGEX))\n       Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n     \n+    if (options.containsKey(ENCODING)) {\n+      try {\n+        this.encoding = options.get(ENCODING);\n+        @SuppressWarnings(\"unused\")\n+        String test = new String(\"test\".getBytes(), encoding);\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+        return false;\n+      }\n+    }\n+    \n     return true;\n   }\n   \n@@ -192,4 +214,19 @@ public static void setRegexs(IteratorSetting si, String rowTerm, String cfTerm,\n       si.addOption(RegExFilter.OR_FIELDS, \"true\");\n     }\n   }\n+  \n+  /**\n+   * Set the encoding string to use when interpreting characters\n+   * \n+   * @param si\n+   *          ScanIterator config to be updated\n+   * @param encoding\n+   *          the encoding string to use for character interpretation.\n+   * \n+   */\n+  public static void setEncoding(IteratorSetting si, String encoding) {\n+    if (!encoding.isEmpty()) {\n+      si.addOption(RegExFilter.ENCODING, encoding);\n+    }\n+  }\n }\n",
    "project": "accumulo",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}