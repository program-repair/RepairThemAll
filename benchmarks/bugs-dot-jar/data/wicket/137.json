{
    "bug_id": 137,
    "classification": {
        "singleLine": false
    },
    "commit": "6a8fc1cc",
    "failing_tests": [
        "org.apache.wicket.markup.resolver.issue3989.Issue3989Test"
    ],
    "files": 4,
    "jira_id": "3989",
    "linesAdd": 51,
    "linesRem": 17,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 2,
    "nb_test": 1130,
    "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex 30671b47ab..d8ac442f21 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -24,6 +24,7 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -41,6 +42,40 @@ public AbstractMarkupSourcingStrategy()\n \n \tpublic abstract IMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n \n+\t/**\n+\t * If the child has not been directly added to the container, but via a\n+\t * TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\n+\t * markup elements and searches for associated components, not the other way around. Because of\n+\t * TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\n+\t * possible.\n+\t * \n+\t * @param container\n+\t *            the parent container.\n+\t * @param child\n+\t *            The component to find the markup for.\n+\t * @return the markup fragment for the child, or {@code null}.\n+\t */\n+\tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n+\t\tfinal Component child)\n+\t{\n+\t\tIMarkupFragment markup = null;\n+\n+\t\tfor (Component ch : container)\n+\t\t{\n+\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n+\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t{\n+\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\t\t\tif (markup != null)\n+\t\t\t\t{\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn markup;\n+\t}\n+\n \t/**\n \t * Make sure we open up open-close tags to open-body-close\n \t */\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\nindex 3b61f9702a..d3196c6240 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n@@ -119,6 +119,12 @@ public IMarkupFragment getMarkup(final MarkupContainer parent, final Component c\n \t\t\treturn associatedMarkup;\n \t\t}\n \n+\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n+\t\tif (associatedMarkup != null)\n+\t\t{\n+\t\t\treturn associatedMarkup;\n+\t\t}\n+\n \t\treturn findMarkupInAssociatedFileHeader(parent, child);\n \t}\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 9173181a71..24a09e9c45 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -23,7 +23,6 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.html.list.AbstractItem;\n-import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -32,7 +31,7 @@\n  * \n  * @author Juergen Donnerstag\n  */\n-public final class DefaultMarkupSourcingStrategy implements IMarkupSourcingStrategy\n+public final class DefaultMarkupSourcingStrategy extends AbstractMarkupSourcingStrategy\n {\n \t/** Log for reporting. */\n \tprivate static final Logger log = LoggerFactory.getLogger(DefaultMarkupSourcingStrategy.class);\n@@ -58,6 +57,7 @@ private DefaultMarkupSourcingStrategy()\n \t/**\n \t * Nothing to add to the response by default\n \t */\n+\t@Override\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\n \t{\n \t}\n@@ -65,6 +65,7 @@ public void onComponentTag(final Component component, final ComponentTag tag)\n \t/**\n \t * Invoke the component's onComponentTagBody().\n \t */\n+\t@Override\n \tpublic void onComponentTagBody(final Component component, final MarkupStream markupStream,\n \t\tfinal ComponentTag openTag)\n \t{\n@@ -74,6 +75,7 @@ public void onComponentTagBody(final Component component, final MarkupStream mar\n \t/**\n \t * Get the markup for the child component, which is assumed to be a child of 'container'.\n \t */\n+\t@Override\n \tpublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child)\n \t{\n \t\t// If the sourcing strategy did not provide one, than ask the component.\n@@ -96,23 +98,11 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \n-\t\t// If the child has not been directly added to the container, but via a\n-\t\t// TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over\n-\t\t// the markup elements and searches for associated components, not the other way around.\n-\t\t// Because of TransparentWebMarkupContainer (or more generally resolvers), there is no\n-\t\t// \"synchronous\" search possible.\n-\t\tfor (Component ch : container)\n-\t\t{\n-\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n-\t\t\t\t(ch instanceof IComponentResolver))\n-\t\t\t{\n-\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n \t\tif (markup != null)\n \t\t{\n \t\t\treturn markup;\n \t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t// This is to make migration for Items from 1.4 to 1.5 more easy\n \t\tif (Character.isDigit(child.getId().charAt(0)))\n@@ -156,6 +146,7 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t/**\n \t * Empty: nothing will be added to the header by default\n \t */\n+\t@Override\n \tpublic void renderHead(final Component component, HtmlHeaderContainer container)\n \t{\n \t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\nindex bfc2240853..7cc8fb262b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n@@ -22,6 +22,7 @@\n import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Markup sourcing strategies determine whether a Component behaves like a \"Panel\" pulling its\n@@ -79,10 +80,11 @@ void onComponentTagBody(final Component component, final MarkupStream markupStre\n \t * @see MarkupContainer#getMarkup(Component)\n \t * \n \t * @param container\n-\t *            The parent containing the child. (@TODO Is container ever != child.getParent()??)\n+\t *            The parent containing the child. This is not the direct parent, transparent\n+\t *            component {@link IComponentResolver resolver} may be in the hierarchy between.\n \t * @param child\n \t *            The component to find the markup for.\n-\t * @return markup fragment\n+\t * @return the markup fragment for the child, or {@code null}.\n \t */\n \tIMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n }\n",
    "project": "wicket",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}