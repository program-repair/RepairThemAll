{
    "bug_id": 77,
    "classification": {
        "singleLine": false
    },
    "commit": "0eb596df",
    "failing_tests": [
        "org.apache.wicket.markup.html.panel.FencedFeedbackPanelTest"
    ],
    "files": 1,
    "jira_id": "5265",
    "linesAdd": 36,
    "linesRem": 11,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 1,
    "nb_test": 1688,
    "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\nindex f7df59ec21..42e134405f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n@@ -29,13 +29,13 @@\n  * the nesting of these panels to work correctly without displaying the same feedback message twice.\n  * A constructor that does not takes a fencing component creates a catch-all panel that shows\n  * messages that do not come from inside any fence or from the {@link Session}.\n- * \n+ * <p/>\n  * <h2>IN DEPTH EXPLANATION</h2>\n  * <p>\n  * It is often very useful to have feedback panels that show feedback that comes from inside a\n  * certain container only. For example given a page with the following structure:\n  * </p>\n- * \n+ * <p/>\n  * <pre>\n  * Page\n  *   Form1\n@@ -112,10 +112,9 @@ public FencedFeedbackPanel(String id, Component fence)\n \t/**\n \t * Creates a catch-all instance with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String)\n-\t * \n \t * @param id\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String)\n \t */\n \tpublic FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t{\n@@ -125,23 +124,27 @@ public FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t/**\n \t * Creates a fenced feedback panel with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String, Component)\n-\t * \n \t * @param id\n \t * @param fence\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String, Component)\n \t */\n \tpublic FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter filter)\n \t{\n \t\tsuper(id, filter);\n \t\tthis.fence = fence;\n \t\tif (fence != null)\n+\t\t{\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void incrementFenceCount()\n \t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = count == null ? 1 : count + 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected void onRemove()\n@@ -151,11 +154,16 @@ protected void onRemove()\n \t\t{\n \t\t\t// decrement the fence count\n \n+\t\t\tdecrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void decrementFenceCount()\n+\t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = (count == null || count == 1) ? null : count - 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected FeedbackMessagesModel newFeedbackMessagesModel()\n@@ -177,7 +185,7 @@ protected FeedbackMessagesModel newFeedbackMessagesModel()\n \t\t\t\t\t\t@Override\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.collect(filter);\n \t\t\t\t}\n@@ -191,12 +199,29 @@ protected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// only recurse into components that are not fences\n-\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.setIncludeSession(false).collect(filter);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t}\n+\n+\tprivate boolean componentIsMarkedAsFence(Component component)\n+\t{\n+\t\treturn component.getMetaData(FENCE_KEY) != null;\n+\t}\n+\n+\t@Override\n+\tprotected void onReAdd()\n+\t{\n+\t\tif (this.fence != null)\n+\t\t{\n+\t\t\t// The fence mark is removed when the feedback panel is removed from the hierarchy.\n+\t\t\t// see onRemove().\n+\t\t\t// when the panel is re-added, we recreate the fence mark.\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t\tsuper.onReAdd();\n+\t}\n }\n",
    "project": "wicket",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}