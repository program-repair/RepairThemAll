{
    "bug_id": 120,
    "classification": {
        "singleLine": false
    },
    "commit": "43956f93",
    "failing_tests": [
        "org.apache.camel.component.properties.PropertiesComponentConcatenatePropertiesTest"
    ],
    "files": 1,
    "jira_id": "7429",
    "linesAdd": 212,
    "linesRem": 123,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 3,
    "nb_test": 4976,
    "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\nindex f7bffa7274..1ee227af62 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n@@ -16,19 +16,17 @@\n  */\n package org.apache.camel.component.properties;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.HashSet;\n import java.util.Properties;\n+import java.util.Set;\n \n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.StringHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.lang.String.format;\n+\n /**\n  * A parser to parse a string which contains property placeholders\n- *\n- * @version \n  */\n public class DefaultPropertiesParser implements AugmentedPropertyNameAwarePropertiesParser {\n     protected final Logger log = LoggerFactory.getLogger(getClass());\n@@ -38,167 +36,258 @@ public String parseUri(String text, Properties properties, String prefixToken, S\n         return parseUri(text, properties, prefixToken, suffixToken, null, null, false);\n     }\n \n-    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken,\n-                           String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n-        String answer = text;\n-        boolean done = false;\n+    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                           boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n+        ParsingContext context = new ParsingContext(properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+        return context.parse(text);\n+    }\n \n-        // the placeholders can contain nested placeholders so we need to do recursive parsing\n-        // we must therefore also do circular reference check and must keep a list of visited keys\n-        List<String> visited = new ArrayList<String>();\n-        while (!done) {\n-            List<String> replaced = new ArrayList<String>();\n-            answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+    public String parseProperty(String key, String value, Properties properties) {\n+        return value;\n+    }\n+\n+    /**\n+     * This inner class helps replacing properties.\n+     */\n+    private final class ParsingContext {\n+        private final Properties properties;\n+        private final String prefixToken;\n+        private final String suffixToken;\n+        private final String propertyPrefix;\n+        private final String propertySuffix;\n+        private final boolean fallbackToUnaugmentedProperty;\n+\n+        public ParsingContext(Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                              boolean fallbackToUnaugmentedProperty) {\n+            this.properties = properties;\n+            this.prefixToken = prefixToken;\n+            this.suffixToken = suffixToken;\n+            this.propertyPrefix = propertyPrefix;\n+            this.propertySuffix = propertySuffix;\n+            this.fallbackToUnaugmentedProperty = fallbackToUnaugmentedProperty;\n+        }\n \n-            // check the replaced with the visited to avoid circular reference\n-            for (String replace : replaced) {\n-                if (visited.contains(replace)) {\n-                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\n+        /**\n+         * Parses the given input string and replaces all properties\n+         *\n+         * @param input Input string\n+         * @return Evaluated string\n+         */\n+        public String parse(String input) {\n+            return doParse(input, new HashSet<String>());\n         }\n+\n+        /**\n+         * Recursively parses the given input string and replaces all properties\n+         *\n+         * @param input                Input string\n+         * @param replacedPropertyKeys Already replaced property keys used for tracking circular references\n+         * @return Evaluated string\n+         */\n+        private String doParse(String input, Set<String> replacedPropertyKeys) {\n+            String answer = input;\n+            Property property;\n+            while ((property = readProperty(answer)) != null) {\n+                // Check for circular references\n+                if (replacedPropertyKeys.contains(property.getKey())) {\n+                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + property.getKey() + \"] from text: \" + input);\n                 }\n-            // okay all okay so add the replaced as visited\n-            visited.addAll(replaced);\n \n-            // we are done when we can no longer find any prefix tokens in the answer\n-            done = findTokenPosition(answer, 0, prefixToken) == -1;\n+                Set<String> newReplaced = new HashSet<String>(replacedPropertyKeys);\n+                newReplaced.add(property.getKey());\n+\n+                String before = answer.substring(0, property.getBeginIndex());\n+                String after = answer.substring(property.getEndIndex());\n+                answer = before + doParse(property.getValue(), newReplaced) + after;\n             }\n             return answer;\n         }\n \n-    public String parseProperty(String key, String value, Properties properties) {\n-        return value;\n+        /**\n+         * Finds a property in the given string. It returns {@code null} if there's no property defined.\n+         *\n+         * @param input Input string\n+         * @return A property in the given string or {@code null} if not found\n+         */\n+        private Property readProperty(String input) {\n+            // Find the index of the first valid suffix token\n+            int suffix = getSuffixIndex(input);\n+\n+            // If not found, ensure that there is no valid prefix token in the string\n+            if (suffix == -1) {\n+                if (getMatchingPrefixIndex(input, input.length()) != -1) {\n+                    throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", suffixToken, input));\n+                }\n+                return null;\n             }\n \n-    private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken,\n-                              String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\n-        StringBuilder sb = new StringBuilder();\n+            // Find the index of the prefix token that matches the suffix token\n+            int prefix = getMatchingPrefixIndex(input, suffix);\n+            if (prefix == -1) {\n+                throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", prefixToken, input));\n+            }\n \n-        int pivot = 0;\n-        int size = uri.length();\n-        while (pivot < size) {\n-            int idx = findTokenPosition(uri, pivot, prefixToken);\n-            if (idx < 0) {\n-                sb.append(createConstantPart(uri, pivot, size));\n-                break;\n-            } else {\n-                if (pivot < idx) {\n-                    sb.append(createConstantPart(uri, pivot, idx));\n+            String key = input.substring(prefix + prefixToken.length(), suffix);\n+            String value = getPropertyValue(key, input);\n+            return new Property(prefix, suffix + suffixToken.length(), key, value);\n         }\n-                pivot = idx + prefixToken.length();\n-                int endIdx = findTokenPosition(uri, pivot, suffixToken);\n-                if (endIdx < 0) {\n-                    throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\n+\n+        /**\n+         * Gets the first index of the suffix token that is not surrounded by quotes\n+         *\n+         * @param input Input string\n+         * @return First index of the suffix token that is not surrounded by quotes\n+         */\n+        private int getSuffixIndex(String input) {\n+            int index = -1;\n+            do {\n+                index = input.indexOf(suffixToken, index + 1);\n+            } while (index != -1 && isQuoted(input, index, suffixToken));\n+            return index;\n         }\n-                String key = uri.substring(pivot, endIdx);\n-                String augmentedKey = key;\n \n-                if (propertyPrefix != null) {\n-                    log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n-                    augmentedKey = propertyPrefix + augmentedKey;\n+        /**\n+         * Gets the index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         *\n+         * @param input       Input string\n+         * @param suffixIndex Index of the suffix token\n+         * @return Index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         */\n+        private int getMatchingPrefixIndex(String input, int suffixIndex) {\n+            int index = suffixIndex;\n+            do {\n+                index = input.lastIndexOf(prefixToken, index - 1);\n+            } while (index != -1 && isQuoted(input, index, prefixToken));\n+            return index;\n         }\n \n-                if (propertySuffix != null) {\n-                    log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n-                    augmentedKey = augmentedKey + propertySuffix;\n+        /**\n+         * Indicates whether or not the token at the given index is surrounded by single or double quotes\n+         *\n+         * @param input Input string\n+         * @param index Index of the token\n+         * @param token Token\n+         * @return {@code true}\n+         */\n+        private boolean isQuoted(String input, int index, String token) {\n+            int beforeIndex = index - 1;\n+            int afterIndex = index + token.length();\n+            if (beforeIndex >= 0 && afterIndex < input.length()) {\n+                char before = input.charAt(beforeIndex);\n+                char after = input.charAt(afterIndex);\n+                return (before == after) && (before == '\\'' || before == '\"');\n+            }\n+            return false;\n         }\n \n-                String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\n+        /**\n+         * Gets the value of the property with given key\n+         *\n+         * @param key   Key of the property\n+         * @param input Input string (used for exception message if value not found)\n+         * @return Value of the property with the given key\n+         */\n+        private String getPropertyValue(String key, String input) {\n+            String augmentedKey = getAugmentedKey(key);\n+            boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey);\n \n-                // Note: Only fallback to unaugmented when the original key was actually augmented\n-                if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n-                    log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n-                    part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\n+            String value = doGetPropertyValue(augmentedKey);\n+            if (value == null && shouldFallback) {\n+                log.debug(\"Property with key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n+                value = doGetPropertyValue(key);\n             }\n \n-                if (part == null) {\n+            if (value == null) {\n                 StringBuilder esb = new StringBuilder();\n                 esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\n-                    if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n+                if (shouldFallback) {\n                     esb.append(\"(and original key [\").append(key).append(\"]) \");\n                 }\n-                    esb.append(\"not found in properties from text: \").append(uri);\n+                esb.append(\"not found in properties from text: \").append(input);\n                 throw new IllegalArgumentException(esb.toString());\n             }\n-                sb.append(part);\n-                pivot = endIdx + suffixToken.length();\n-            }\n-        }\n-        return sb.toString();\n-    }\n \n-    private int findTokenPosition(String uri, int pivot, String token) {\n-        int idx = uri.indexOf(token, pivot);\n-        while (idx > 0) {\n-            // grab part as the previous char + token + next char, to test if the token is quoted\n-            String part = null;\n-            int len = idx + token.length() + 1;\n-            if (uri.length() >= len) {\n-                part = uri.substring(idx - 1, len);\n+            return value;\n         }\n-            if (StringHelper.isQuoted(part)) {\n-                // the token was quoted, so regard it as a literal\n-                // and then try to find from next position\n-                pivot = idx + token.length() + 1;\n-                idx = uri.indexOf(token, pivot);\n-            } else {\n-                // found token\n-                return idx;\n+\n+        /**\n+         * Gets the augmented key of the given base key\n+         *\n+         * @param key Base key\n+         * @return Augmented key\n+         */\n+        private String getAugmentedKey(String key) {\n+            String augmentedKey = key;\n+            if (propertyPrefix != null) {\n+                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n+                augmentedKey = propertyPrefix + augmentedKey;\n             }\n+            if (propertySuffix != null) {\n+                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n+                augmentedKey = augmentedKey + propertySuffix;\n             }\n-        return idx;\n+            return augmentedKey;\n         }\n \n-    private boolean isNestProperty(String uri, String prefixToken, String suffixToken) {\n-        if (ObjectHelper.isNotEmpty(uri)) {\n-            uri = uri.trim();\n-            if (uri.startsWith(prefixToken) && uri.endsWith(suffixToken)) {\n-                return true;\n+        /**\n+         * Gets the property with the given key, it returns {@code null} if the property is not found\n+         *\n+         * @param key Key of the property\n+         * @return Value of the property or {@code null} if not found\n+         */\n+        private String doGetPropertyValue(String key) {\n+            String value = System.getProperty(key);\n+            if (value != null) {\n+                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, value);\n+            } else if (properties != null) {\n+                value = properties.getProperty(key);\n             }\n+            return value;\n         }\n-        return false;\n     }\n \n-    private String takeOffNestTokes(String uri, String prefixToken, String suffixToken) {\n-        int start = prefixToken.length(); \n-        int end = uri.length() - suffixToken.length();\n-        return uri.substring(start, end); \n-    }\n+    /**\n+     * This inner class is the definition of a property used in a string\n+     */\n+    private static final class Property {\n+        private final int beginIndex;\n+        private final int endIndex;\n+        private final String key;\n+        private final String value;\n \n-    private String createConstantPart(String uri, int start, int end) {\n-        return uri.substring(start, end);\n+        private Property(int beginIndex, int endIndex, String key, String value) {\n+            this.beginIndex = beginIndex;\n+            this.endIndex = endIndex;\n+            this.key = key;\n+            this.value = value;\n         }\n \n-    private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n-        // keep track of which parts we have replaced\n-        replaced.add(key);\n-        \n-        String propertyValue = System.getProperty(key);\n-        if (propertyValue != null) {\n-            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-        } else if (properties != null) {\n-            propertyValue = properties.getProperty(key);\n-        }\n-        \n-        // we need to check if the propertyValue is nested\n-        // we need to check if there is cycle dependency of the nested properties\n-        List<String> visited = new ArrayList<String>();\n-        while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n-            visited.add(key);\n-            // need to take off the token first\n-            String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n-            key = parseUri(value, properties, prefixToken, suffixToken);\n-            if (visited.contains(key)) {\n-                throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n-            }\n-            propertyValue = System.getProperty(key);\n-            if (propertyValue != null) {\n-                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-            } else if (properties != null) {\n-                propertyValue = properties.getProperty(key);\n+        /**\n+         * Gets the begin index of the property (including the prefix token).\n+         */\n+        public int getBeginIndex() {\n+            return beginIndex;\n         }\n+\n+        /**\n+         * Gets the end index of the property (including the suffix token).\n+         */\n+        public int getEndIndex() {\n+            return endIndex;\n         }\n \n-        return parseProperty(key, propertyValue, properties);\n+        /**\n+         * Gets the key of the property.\n+         */\n+        public String getKey() {\n+            return key;\n         }\n \n+        /**\n+         * Gets the value of the property.\n+         */\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n }\n",
    "project": "camel",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}