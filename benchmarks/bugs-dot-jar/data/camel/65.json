{
    "bug_id": 65,
    "classification": {
        "singleLine": false
    },
    "commit": "020c451a",
    "failing_tests": [
        "org.apache.camel.processor.async.AsyncNestedTripleChoiceIssueTest",
        "org.apache.camel.processor.TripleNestedChoiceIssueTest",
        "org.apache.camel.processor.NestedChoiceIssueTest"
    ],
    "files": 2,
    "jira_id": "6447",
    "linesAdd": 47,
    "linesRem": 77,
    "nb_error": 0,
    "nb_failure": 8,
    "nb_skipped": 1,
    "nb_test": 4665,
    "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 45889c37d0..9998e51c62 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1295,8 +1295,13 @@ public AOPDefinition aop() {\n      * @return the builder\n      */\n     public ChoiceDefinition endChoice() {\n-        // are we already a choice?\n+        // are we nested choice?\n         ProcessorDefinition<?> def = this;\n+        if (def.getParent() instanceof WhenDefinition) {\n+            return (ChoiceDefinition) def.getParent().getParent();\n+        }\n+\n+        // are we already a choice?\n         if (def instanceof ChoiceDefinition) {\n             return (ChoiceDefinition) def;\n         }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\nindex 5af8b360fd..0310c9a02d 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n@@ -30,10 +30,6 @@\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ServiceHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.camel.processor.PipelineHelper.continueProcessing;\n \n /**\n  * Implements a Choice structure where one or more predicates are used which if\n@@ -43,7 +39,6 @@\n  * @version \n  */\n public class ChoiceProcessor extends ServiceSupport implements AsyncProcessor, Navigate<Processor>, Traceable {\n-    private static final Logger LOG = LoggerFactory.getLogger(ChoiceProcessor.class);\n     private final List<Processor> filters;\n     private final Processor otherwise;\n \n@@ -56,91 +51,61 @@ public void process(Exchange exchange) throws Exception {\n         AsyncProcessorHelper.process(this, exchange);\n     }\n \n-    public boolean process(Exchange exchange, AsyncCallback callback) {\n+    public boolean process(final Exchange exchange, final AsyncCallback callback) {\n         Iterator<Processor> processors = next().iterator();\n \n-        exchange.setProperty(Exchange.FILTER_MATCHED, false);\n-        while (continueRouting(processors, exchange)) {\n-            // get the next processor\n-            Processor processor = processors.next();\n-\n-            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n-            boolean sync = process(exchange, callback, processors, async);\n-\n-            // continue as long its being processed synchronously\n-            if (!sync) {\n-                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                // the remainder of the CBR will be completed async\n-                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n-                return false;\n-            }\n-\n-            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n-\n-            // check for error if so we should break out\n-            if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n-                break;\n+        // callback to restore existing FILTER_MATCHED property on the Exchange\n+        final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);\n+        final AsyncCallback choiceCallback = new AsyncCallback() {\n+            @Override\n+            public void done(boolean doneSync) {\n+                if (existing != null) {\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, existing);\n+                } else {\n+                    exchange.removeProperty(Exchange.FILTER_MATCHED);\n                 }\n+                callback.done(doneSync);\n             }\n+        };\n \n-        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n+        // as we only pick one processor to process, then no need to have async callback that has a while loop as well\n+        // as this should not happen, eg we pick the first filter processor that matches, or the otherwise (if present)\n+        // and if not, we just continue without using any processor\n+        while (processors.hasNext()) {\n+            // get the next processor\n+            Processor processor = processors.next();\n \n-        callback.done(true);\n+            // evaluate the predicate on filter predicate early to be faster\n+            // and avoid issues when having nested choices\n+            // as we should only pick one processor\n+            boolean matches = true;\n+            if (processor instanceof FilterProcessor) {\n+                FilterProcessor filter = (FilterProcessor) processor;\n+                try {\n+                    matches = filter.getPredicate().matches(exchange);\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n+                } catch (Throwable e) {\n+                    exchange.setException(e);\n+                    choiceCallback.done(true);\n                     return true;\n                 }\n-\n-    protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n-        boolean answer = it.hasNext();\n-        if (answer) {\n-            Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\n-            if (matched != null) {\n-                boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\n-                if (hasMatched) {\n-                    LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\n-                    answer = false;\n+                // as we have pre evaluated the predicate then use its processor directly when routing\n+                processor = filter.getProcessor();\n             }\n-            }\n-        }\n-        LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\n-        return answer;\n-    }\n-\n-    private boolean process(final Exchange exchange, final AsyncCallback callback,\n-                            final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n-        // this does the actual processing so log at trace level\n-        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-\n-        // implement asynchronous routing logic in callback so we can have the callback being\n-        // triggered and then continue routing where we left\n-        boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n-            public void done(boolean doneSync) {\n-                // we only have to handle async completion of the pipeline\n-                if (doneSync) {\n-                    return;\n-                }\n-\n-                // continue processing the pipeline asynchronously\n-                while (continueRouting(processors, exchange)) {\n-                    AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n \n-                    // check for error if so we should break out\n-                    if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n-                        break;\n+            // if we did not match then continue to next filter\n+            if (!matches) {\n+                continue;\n             }\n \n-                    doneSync = process(exchange, callback, processors, processor);\n-                    if (!doneSync) {\n-                        LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                        return;\n-                    }\n-                }\n-\n-                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-                callback.done(false);\n+            // okay we found a filter or its the otherwise we are processing\n+            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n+            return async.process(exchange, choiceCallback);\n         }\n-        });\n \n-        return sync;\n+        // when no filter matches and there is no otherwise, then just continue\n+        choiceCallback.done(true);\n+        return true;\n     }\n \n     @Override\n",
    "project": "camel",
    "buggy_compile_success": false,
    "buggy_test_success": false,
    "fixed_compile_success": false,
    "fixed_test_success": false
}