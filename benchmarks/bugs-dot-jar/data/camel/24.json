{
    "bug_id": 24,
    "classification": {
        "singleLine": false
    },
    "commit": "78c73502",
    "failing_tests": [
        "org.apache.camel.processor.SplitterParallelStopOnExceptionTest",
        "org.apache.camel.processor.RecipientListParallelFineGrainedErrorHandlingTest",
        "org.apache.camel.processor.MulticastParallelStopOnExceptionTest",
        "org.apache.camel.processor.onexception.DoCatchDirectRecipientListTest"
    ],
    "files": 2,
    "jira_id": "5681",
    "linesAdd": 10,
    "linesRem": 14,
    "nb_error": 1,
    "nb_failure": 3,
    "nb_skipped": 1,
    "nb_test": 4318,
    "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex e538801fab..b2930f68c6 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -200,19 +200,11 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         final AtomicExchange result = new AtomicExchange();\n         final Iterable<ProcessorExchangePair> pairs;\n \n-        // multicast uses fine grained error handling on the output processors\n-        // so use try .. catch to cater for this\n-        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n \n-            // after we have created the processors we consider the exchange as exhausted if an unhandled\n-            // exception was thrown, (used in the catch block)\n-            // if the processors is working in Streaming model, the exchange could not be processed at this point.\n-            exhaust = !isStreaming();\n-\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -228,15 +220,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n             }\n         } catch (Throwable e) {\n             exchange.setException(e);\n+            // unexpected exception was thrown, maybe from iterator etc. so do not regard as exhausted\n             // and do the done work\n-            doDone(exchange, null, callback, true, exhaust);\n+            doDone(exchange, null, callback, true, false);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true, exhaust);\n+        doDone(exchange, subExchange, callback, true, true);\n         return true;\n     }\n \n@@ -308,7 +301,8 @@ public Exchange call() throws Exception {\n                             // throw caused exception\n                             if (subExchange.getException() != null) {\n                                 // wrap in exception to explain where it failed\n-                                throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                CamelExchangeException cause = new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                subExchange.setException(cause);\n                             }\n                         }\n \n@@ -527,15 +521,15 @@ protected boolean doProcessSequential(Exchange original, AtomicExchange result,\n             if (stopOnException && !continueProcessing) {\n                 if (subExchange.getException() != null) {\n                     // wrap in exception to explain where it failed\n-                    throw new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n-                } else {\n+                    CamelExchangeException cause = new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n+                    subExchange.setException(cause);\n+                }\n                 // we want to stop on exception, and the exception was handled by the error handler\n                 // this is similar to what the pipeline does, so we should do the same to not surprise end users\n                 // so we should set the failed exchange as the result and be done\n                 result.set(subExchange);\n                 return true;\n             }\n-            }\n \n             LOG.trace(\"Sequential processing complete for number {} exchange: {}\", total, subExchange);\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\nindex 9c4b00d8e8..6cac402f18 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n@@ -361,6 +361,8 @@ protected boolean processNext(final Exchange exchange, final AsyncCallback callb\n             // give the rest of the pipeline another chance\n             exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\n             exchange.setException(null);\n+            // and we should not be regarded as exhausted as we are in a try .. catch block\n+            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n \n             // is the exception handled by the catch clause\n             final Boolean handled = catchClause.handles(exchange);\n",
    "project": "camel"
}