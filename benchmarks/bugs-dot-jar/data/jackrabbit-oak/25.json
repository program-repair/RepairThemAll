{
    "bug_id": 25,
    "classification": {
        "singleLine": false
    },
    "commit": "cdb34ffc",
    "failing_tests": [
        "org.apache.jackrabbit.oak.segment.SegmentBufferWriterPoolTest"
    ],
    "files": 2,
    "jira_id": "4291",
    "linesAdd": 100,
    "linesRem": 9,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 1,
    "nb_test": 144,
    "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\nindex c035323e22..610b3ca55a 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n@@ -34,6 +34,8 @@\n import javax.annotation.Nonnull;\n \n import com.google.common.base.Supplier;\n+import com.google.common.util.concurrent.Monitor;\n+import com.google.common.util.concurrent.Monitor.Guard;\n \n /**\n  * This {@link WriteOperationHandler} uses a pool of {@link SegmentBufferWriter}s,\n@@ -43,8 +45,27 @@\n  * {@link SegmentWriter}.\n  */\n public class SegmentBufferWriterPool implements WriteOperationHandler {\n+\n+    /**\n+     * Monitor protecting the state of this pool. Neither of {@link #writers},\n+     * {@link #borrowed} and {@link #disposed} must be modified without owning\n+     * this monitor.\n+     */\n+    private final Monitor poolMonitor = new Monitor(true);\n+\n+    /**\n+     * Pool of current writers that are not in use\n+     */\n     private final Map<Object, SegmentBufferWriter> writers = newHashMap();\n+\n+    /**\n+     * Writers that are currently in use\n+     */\n     private final Set<SegmentBufferWriter> borrowed = newHashSet();\n+\n+    /**\n+     * Retired writers that have not yet been flushed\n+     */\n     private final Set<SegmentBufferWriter> disposed = newHashSet();\n \n     @Nonnull\n@@ -95,21 +116,82 @@ public RecordId execute(WriteOperation writeOperation) throws IOException {\n     @Override\n     public void flush() throws IOException {\n         List<SegmentBufferWriter> toFlush = newArrayList();\n-        synchronized (this) {\n+        List<SegmentBufferWriter> toReturn = newArrayList();\n+\n+        poolMonitor.enter();\n+        try {\n+            // Collect all writers that are not currently in use and clear\n+            // the list so they won't get re-used anymore.\n             toFlush.addAll(writers.values());\n-            toFlush.addAll(disposed);\n             writers.clear();\n-            disposed.clear();\n+\n+            // Collect all borrowed writers, which we need to wait for.\n+            // Clear the list so they will get disposed once returned.\n+            toReturn.addAll(borrowed);\n             borrowed.clear();\n+        } finally {\n+            poolMonitor.leave();\n+        }\n+\n+        // Wait for the return of the borrowed writers. This is the\n+        // case once all of them appear in the disposed set.\n+        if (safeEnterWhen(poolMonitor, allReturned(toReturn))) {\n+            try {\n+                // Collect all disposed writers and clear the list to mark them\n+                // as flushed.\n+                toFlush.addAll(toReturn);\n+                disposed.removeAll(toReturn);\n+            } finally {\n+                poolMonitor.leave();\n+            }\n         }\n-        // Call flush from outside a synchronized context to avoid\n+\n+        // Call flush from outside the pool monitor to avoid potential\n         // deadlocks of that method calling SegmentStore.writeSegment\n         for (SegmentBufferWriter writer : toFlush) {\n             writer.flush();\n         }\n     }\n \n-    private synchronized SegmentBufferWriter borrowWriter(Object key) {\n+    /**\n+     * Create a {@code Guard} that is satisfied if and only if {@link #disposed}\n+     * contains all items in {@code toReturn}\n+     */\n+    @Nonnull\n+    private Guard allReturned(final List<SegmentBufferWriter> toReturn) {\n+        return new Guard(poolMonitor) {\n+\n+            @Override\n+            public boolean isSatisfied() {\n+                return disposed.containsAll(toReturn);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Same as {@code monitor.enterWhen(guard)} but copes with that pesky {@code\n+     * InterruptedException} by catching it and setting this thread's\n+     * interrupted flag.\n+     */\n+    private static boolean safeEnterWhen(Monitor monitor, Guard guard) {\n+        try {\n+            monitor.enterWhen(guard);\n+            return true;\n+        } catch (InterruptedException ignore) {\n+            Thread.currentThread().interrupt();\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Return a writer from the pool by its {@code key}. This method may return\n+     * a fresh writer at any time. Callers need to return a writer before\n+     * borrowing it again. Failing to do so leads to undefined behaviour.\n+     */\n+    private SegmentBufferWriter borrowWriter(Object key) {\n+        poolMonitor.enter();\n+        try {\n             SegmentBufferWriter writer = writers.remove(key);\n             if (writer == null) {\n                 writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\n@@ -119,15 +201,27 @@ private synchronized SegmentBufferWriter borrowWriter(Object key) {\n             }\n             borrowed.add(writer);\n             return writer;\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n-    private synchronized void returnWriter(Object key, SegmentBufferWriter writer) {\n+    /**\n+     * Return a writer to the pool using the {@code key} that was used to borrow\n+     * it.\n+     */\n+    private void returnWriter(Object key, SegmentBufferWriter writer) {\n+        poolMonitor.enter();\n+        try {\n             if (borrowed.remove(writer)) {\n                 checkState(writers.put(key, writer) == null);\n             } else {\n                 // Defer flush this writer as it was borrowed while flush() was called.\n                 disposed.add(writer);\n             }\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n     private String getWriterId(String wid) {\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\nindex 1a585c09a2..b122a0a6d5 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n@@ -58,9 +58,6 @@\n \n     /**\n      * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\n-     * This method <em>does not block</em> to wait for concurrent write operations. However, if\n-     * a write operation is currently in progress a call to this method ensures the respective\n-     * changes are properly flushed at the end of that call.\n      * @throws IOException\n      */\n     void flush() throws IOException;\n",
    "project": "jackrabbit-oak"
}