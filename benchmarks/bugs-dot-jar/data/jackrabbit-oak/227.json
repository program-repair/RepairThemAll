{
    "bug_id": 227,
    "classification": {
        "singleLine": false
    },
    "commit": "a9efe3c4",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
    ],
    "files": 5,
    "jira_id": "1215",
    "linesAdd": 117,
    "linesRem": 64,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 6,
    "nb_test": 1562,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\nindex 40786b4470..963865d278 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n@@ -52,9 +52,10 @@ public void setQuery(QueryImpl query) {\n     \n     /**\n      * Normalize the property name (including namespace remapping).\n+     * Asterisks are kept.\n      *\n      * @param propertyName the property name to normalize\n-     * @return the normalized property name\n+     * @return the normalized (oak-) property name\n      */\n     protected String normalizePropertyName(String propertyName) {\n         // TODO normalize the path (remove superfluous \"..\" and \".\" \n@@ -71,7 +72,23 @@ protected String normalizePropertyName(String propertyName) {\n         }\n         // relative properties\n         String relativePath = PathUtils.getParentPath(propertyName);\n+        if (relativePath.indexOf('*') >= 0) {\n+            StringBuilder buff = new StringBuilder();\n+            for (String p : PathUtils.elements(relativePath)) {\n+                if (!p.equals(\"*\")) {\n+                    p = query.getOakPath(p);\n+                }\n+                if (p.length() > 0) {\n+                    if (buff.length() > 0) {\n+                        buff.append('/');\n+                    }\n+                    buff.append(p);\n+                }\n+            }\n+            relativePath = buff.toString();\n+        } else {\n             relativePath = query.getOakPath(relativePath);\n+        }\n         propertyName = PathUtils.getName(propertyName);\n         propertyName = normalizeNonRelativePropertyName(propertyName);\n         return PathUtils.concat(relativePath, propertyName);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\nindex f1eb90711e..88d56100df 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n@@ -18,7 +18,6 @@\n  */\n package org.apache.jackrabbit.oak.query.ast;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n@@ -26,17 +25,10 @@\n \n import javax.jcr.PropertyType;\n \n-import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n-import org.apache.jackrabbit.oak.api.Tree;\n-import org.apache.jackrabbit.oak.api.Type;\n-import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.SQL2Parser;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n-\n-import com.google.common.collect.Iterables;\n \n /**\n  * A property expression.\n@@ -107,58 +99,13 @@ public PropertyExistenceImpl getPropertyExistence() {\n \n     @Override\n     public PropertyValue currentProperty() {\n-        boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\n-        if (!asterisk) {\n-            PropertyValue p = selector.currentProperty(propertyName);\n-            return matchesPropertyType(p) ? p : null;\n-        }\n-        Tree tree = selector.currentTree();\n-        if (tree == null || !tree.exists()) {\n-            return null;\n-        }\n-        if (!asterisk) {\n-            String name = PathUtils.getName(propertyName);\n-            name = normalizePropertyName(name);\n-            PropertyState p = tree.getProperty(name);\n-            if (p == null) {\n-                return null;\n-            }\n-            return matchesPropertyType(p) ? PropertyValues.create(p) : null;\n-        }\n-        // asterisk - create a multi-value property\n-        // warning: the returned property state may have a mixed type\n-        // (not all values may have the same type)\n-\n-        // TODO currently all property values are converted to strings - \n-        // this doesn't play well with the idea that the types may be different\n-        List<String> values = new ArrayList<String>();\n-        for (PropertyState p : tree.getProperties()) {\n-            if (matchesPropertyType(p)) {\n-                Iterables.addAll(values, p.getValue(Type.STRINGS));\n-            }\n-        }\n-        // \"*\"\n-        return PropertyValues.newString(values);\n-    }\n-\n-    private boolean matchesPropertyType(PropertyValue value) {\n-        if (value == null) {\n-            return false;\n-        }\n-        if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n-        }\n-        return value.getType().tag() == propertyType;\n-    }\n-\n-    private boolean matchesPropertyType(PropertyState state) {\n-        if (state == null) {\n-            return false;\n-        }\n+        PropertyValue p;\n         if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n+            p = selector.currentProperty(propertyName);\n+        } else {\n+            p = selector.currentProperty(propertyName, propertyType);\n         }\n-        return state.getType().tag() == propertyType;\n+        return p;        \n     }\n \n     public void bindSelector(SourceImpl source) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 4d99f0f201..a9c22fd9e3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -40,6 +40,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Tree;\n+import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n@@ -53,6 +54,7 @@\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n \n /**\n  * A selector within a query.\n@@ -385,6 +387,19 @@ public PropertyValue currentProperty(String propertyName) {\n         return currentOakProperty(pn);\n     }\n \n+    /**\n+     * The value for the given selector for the current node, filtered by\n+     * property type.\n+     * \n+     * @param propertyName the JCR (not normalized) property name\n+     * @param propertyType only include properties of this type\n+     * @return the property value (possibly null)\n+     */\n+    public PropertyValue currentProperty(String propertyName, int propertyType) {\n+        String pn = normalizePropertyName(propertyName);\n+        return currentOakProperty(pn, propertyType);\n+    }\n+\n     /**\n      * Get the property value. The property name may be relative. The special\n      * property names \"jcr:path\", \"jcr:score\" and \"rep:excerpt\" are supported.\n@@ -393,6 +408,24 @@ public PropertyValue currentProperty(String propertyName) {\n      * @return the property value or null if not found\n      */\n     public PropertyValue currentOakProperty(String oakPropertyName) {\n+        return currentOakProperty(oakPropertyName, null);\n+    }\n+\n+    private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n+        boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n+        if (asterisk) {\n+            Tree t = currentTree();\n+            ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n+            readOakProperties(list, t, oakPropertyName, propertyType);\n+            if (list.size() == 0) {\n+                return null;\n+            }\n+            ArrayList<String> strings = new ArrayList<String>();\n+            for (PropertyValue p : list) {\n+                Iterables.addAll(strings, p.getValue(Type.STRINGS));\n+            }\n+            return PropertyValues.newString(strings);                    \n+        }\n         boolean relative = oakPropertyName.indexOf('/') >= 0;\n         Tree t = currentTree();\n         if (relative) {\n@@ -410,6 +443,11 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n             }\n             oakPropertyName = PathUtils.getName(oakPropertyName);\n         }\n+        return currentOakProperty(t, oakPropertyName, propertyType);\n+    }\n+    \n+    private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer propertyType) {\n+        PropertyValue result;\n         if (t == null || !t.exists()) {\n             return null;\n         }\n@@ -420,13 +458,59 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n                 // not a local path\n                 return null;\n             }\n-            return PropertyValues.newString(local);\n+            result = PropertyValues.newString(local);\n         } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {\n-            return currentRow.getValue(QueryImpl.JCR_SCORE);\n+            result = currentRow.getValue(QueryImpl.JCR_SCORE);\n         } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {\n-            return currentRow.getValue(QueryImpl.REP_EXCERPT);\n+            result = currentRow.getValue(QueryImpl.REP_EXCERPT);\n+        } else {\n+            result = PropertyValues.create(t.getProperty(oakPropertyName));\n+        }\n+        if (result == null) {\n+            return null;\n+        }\n+        if (propertyType != null && result.getType().tag() != propertyType) {\n+            return null;\n+        }\n+        return result;\n+    }\n+    \n+    private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n+        while (true) {\n+            if (t == null || !t.exists()) {\n+                return;\n+            }\n+            int slash = oakPropertyName.indexOf('/');\n+            if (slash < 0) {\n+                break;\n+            }\n+            String parent = oakPropertyName.substring(0, slash);\n+            oakPropertyName = oakPropertyName.substring(slash + 1);\n+            if (parent.equals(\"..\")) {\n+                t = t.isRoot() ? null : t.getParent();\n+            } else if (parent.equals(\".\")) {\n+                // same node\n+            } else if (parent.equals(\"*\")) {\n+                for (Tree child : t.getChildren()) {\n+                    readOakProperties(target, child, oakPropertyName, propertyType);\n+                }\n+            } else {\n+                t = t.getChild(parent);\n+            }\n+        }\n+        if (!\"*\".equals(oakPropertyName)) {\n+            PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n+            if (value != null) {\n+                target.add(value);\n+            }\n+            return;\n+        }\n+          for (PropertyState p : t.getProperties()) {\n+              if (propertyType == null || p.getType().tag() == propertyType) {\n+                  PropertyValue v = PropertyValues.create(p);\n+                  target.add(v);\n+              }\n           }\n-        return PropertyValues.create(t.getProperty(oakPropertyName));\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 7b95deced0..a545ba88ef 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -176,7 +176,9 @@ public SelectorImpl getExistingSelector(String selectorName) {\n      * \n      * this creates a filter for the given query\n      * \n+     * @param preparing whether this this the prepare phase\n+     * @return a new filter\n      */\n-    abstract public Filter createFilter(boolean preparing);\n+    public abstract Filter createFilter(boolean preparing);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\nindex aa56db06bd..e6ed3a9267 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n@@ -35,6 +35,9 @@\n \n import com.google.common.collect.ImmutableSet;\n \n+/**\n+ * This class can extract excerpts from node.\n+ */\n public class SimpleExcerptProvider {\n \n     private static final String REP_EXCERPT_FN = \"rep:excerpt(.)\";\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}