{
    "bug_id": 221,
    "classification": {
        "singleLine": false
    },
    "commit": "a8493efc",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexTest"
    ],
    "files": 1,
    "jira_id": "537",
    "linesAdd": 27,
    "linesRem": 61,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 1,
    "nb_test": 404,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\nindex bbf71e30fa..7a31ae6197 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n@@ -18,6 +18,7 @@\n \n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n+import java.util.Iterator;\n import java.util.Set;\n \n import javax.annotation.Nullable;\n@@ -25,6 +26,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.index.IndexConstants;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.IndexStoreStrategy;\n@@ -72,22 +74,22 @@ public Property2IndexLookup(NodeState root) {\n      * @return true if the property is indexed\n      */\n     public boolean isIndexed(String name, String path) {\n-        if (getIndexDefinitionNode(name) != null) {\n-            return true;\n+        return isIndexed(root, name, path);\n     }\n     \n-        // TODO use PathUtils\n-        if (path.startsWith(\"/\")) {\n-            path = path.substring(1);\n+    private static boolean isIndexed(NodeState root, String name, String path) {\n+        NodeState node = root;\n+        Iterator<String> it = PathUtils.elements(path).iterator();\n+        while (true) {\n+            if (getIndexDefinitionNode(node, name) != null) {\n+                return true;\n             }\n-        int slash = path.indexOf('/');\n-        if (slash == -1) {\n-            return false;\n+            if (!it.hasNext()) {\n+                break;\n             }\n-\n-        NodeState child = root.getChildNode(path.substring(0, slash));\n-        return new Property2IndexLookup(child).isIndexed(\n-                name, path.substring(slash));\n+            node = node.getChildNode(it.next());\n+        }\n+        return false;\n     }\n     \n     /**\n@@ -112,69 +114,33 @@ public boolean isIndexed(String name, String path) {\n      * @return the set of matched paths\n      */\n     public Set<String> find(String name, PropertyValue value) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            throw new IllegalArgumentException(\"No index for \" + name);\n+        }\n         Set<String> paths = Sets.newHashSet();\n-\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n         state = state.getChildNode(\":index\");\n         if (value == null) {\n             paths.addAll(store.find(state, null));\n         } else {\n             paths.addAll(store.find(state, Property2Index.encode(value)));\n         }\n-        } else {\n-            // No index available, so first check this node for a match\n-            PropertyState property = root.getProperty(name);\n-            if (property != null) {\n-                if (value == null || value.isArray()) {\n-                    // let query engine handle property existence and\n-                    // multi-valued look ups;\n-                    // simply return all nodes that have this property\n-                    paths.add(\"\");\n-                } else {\n-                    // does it match any of the values of this property?\n-                    for (int i = 0; i < property.count(); i++) {\n-                        if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n-                            paths.add(\"\");\n-                            // no need to check for more matches in this property\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // ... and then recursively look up from the rest of the tree\n-            for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n-                String base = entry.getName();\n-                Property2IndexLookup lookup =\n-                        new Property2IndexLookup(entry.getNodeState());\n-                for (String path : lookup.find(name, value)) {\n-                    if (path.isEmpty()) {\n-                        paths.add(base);\n-                    } else {\n-                        paths.add(base + \"/\" + path);\n-                    }\n-                }\n-            }\n-        }\n-\n         return paths;\n     }\n \n     public double getCost(String name, PropertyValue value) {\n-        double cost = 0.0;\n         // TODO the cost method is currently reading all the data - \n         // is not supposed to do that, it is only supposed to estimate\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n         state = state.getChildNode(\":index\");\n+        double cost;\n         if (value == null) {\n-                cost += store.count(state, null);\n-            } else {\n-                cost += store.count(state, Property2Index.encode(value));\n-            }\n+            cost = store.count(state, null);\n         } else {\n-            cost = Double.POSITIVE_INFINITY;\n+            cost = store.count(state, Property2Index.encode(value));\n         }\n         return cost;\n     }\n@@ -187,8 +153,8 @@ public double getCost(String name, PropertyValue value) {\n      *         index definition node was found\n      */\n     @Nullable\n-    private NodeState getIndexDefinitionNode(String name) {\n-        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);\n+    private static NodeState getIndexDefinitionNode(NodeState node, String name) {\n+        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n         if (state != null) {\n             for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                 PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}