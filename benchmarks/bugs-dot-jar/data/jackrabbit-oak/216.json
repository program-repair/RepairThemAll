{
    "bug_id": 216,
    "classification": {
        "singleLine": false
    },
    "commit": "7d72e6ed",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexQueryTest",
        "org.apache.jackrabbit.oak.plugins.index.old.QueryTest"
    ],
    "files": 11,
    "jira_id": "579",
    "linesAdd": 129,
    "linesRem": 18,
    "nb_error": 2,
    "nb_failure": 0,
    "nb_skipped": 6,
    "nb_test": 542,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\nindex 57bf0d1672..002bad8e36 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n@@ -308,7 +308,7 @@ public ResultImpl executeQuery() {\n         prepare();\n         Iterator<ResultRowImpl> it;\n         if (explain) {\n-            String plan = source.getPlan(rootState);\n+            String plan = getPlan();\n             columns = new ColumnImpl[] { new ColumnImpl(\"explain\", \"plan\", \"plan\")};\n             ResultRowImpl r = new ResultRowImpl(this,\n                     new String[0], \n@@ -317,7 +317,7 @@ public ResultImpl executeQuery() {\n             it = Arrays.asList(r).iterator();\n         } else {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"plan: \" + source.getPlan(rootState));\n+                LOG.debug(\"plan: \" + getPlan());\n             }\n             if (orderings == null) {\n                 // can apply limit and offset directly\n@@ -438,6 +438,15 @@ public int compareRows(PropertyValue[] orderValues,\n         return comp;\n     }\n     \n+    /**\n+     * Get the query plan. The query must already be prepared.\n+     * \n+     * @return the query plan\n+     */\n+    private String getPlan() {\n+        return source.getPlan(rootState);\n+    }\n+\n     void prepare() {\n         if (prepared) {\n             return;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\nindex a7569bce82..2a79d6779e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n@@ -176,11 +176,14 @@ public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter)\n                 best = index;\n             }\n         }\n-        if (best == null) {\n+        QueryIndex index = new TraversingIndex();\n+        double cost = index.getCost(filter, rootState);\n         if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n+            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n         }\n-            best = new TraversingIndex();\n+        if (cost < bestCost) {\n+            bestCost = cost;\n+            best = index;\n         }\n         return best;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\nindex 829196abc5..6213557f38 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == parentSelector) {\n             String c = childSelector.currentPath();\n+            if (c == null && f.isPreparing() && childSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                c = KNOWN_PATH;\n+            }\n             if (c != null) {\n                 f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);\n             }\n         }\n         if (f.getSelector() == childSelector) {\n             String p = parentSelector.currentPath();\n+            if (p == null && f.isPreparing() && parentSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p = KNOWN_PATH;\n+            }\n             if (p != null) {\n                 f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\nindex 1552155cf1..8e5f945dcb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == ancestorSelector) {\n             String d = descendantSelector.currentPath();\n+            if (d == null && f.isPreparing() && descendantSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                d = KNOWN_PATH;\n+            }\n             if (d != null) {\n                 f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);\n             }\n         }\n         if (f.getSelector() == descendantSelector) {\n             String a = ancestorSelector.currentPath();\n+            if (a == null && f.isPreparing() && ancestorSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                a = KNOWN_PATH;\n+            }\n             if (a != null) {\n                 f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\nindex dae131d44a..01d1ce29d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n@@ -97,21 +97,35 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             PropertyValue p2 = selector2.currentProperty(property2Name);\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p2 != null) {\n-                if (!p2.isArray()) {\n+                if (p2.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property1Name, Operator.EQUAL, p2);\n+                    p2 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property1Name, Operator.EQUAL, p2);\n         }\n         if (f.getSelector() == selector2) {\n             PropertyValue p1 = selector1.currentProperty(property1Name);\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p1 != null) {\n-                if (!p1.isArray()) {\n+                if (p1.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property2Name, Operator.EQUAL, p1);\n+                    p1 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property2Name, Operator.EQUAL, p1);\n         }\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\nindex b3e2fd54d4..f5c82986d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n@@ -20,10 +20,35 @@\n  */\n public abstract class JoinConditionImpl extends AstElement {\n     \n+    /**\n+     * A path with 6 elements, which is the expected average for a join.\n+     */\n+    protected static final String KNOWN_PATH = \"/path/from/the/join/selector\";\n+\n+    protected static final String KNOWN_VALUE = \"valueFromTheJoinSelector\";\n+\n+    /**\n+     * Evaluate the result using the currently set values.\n+     * \n+     * @return true if the constraint matches\n+     */\n     public abstract boolean evaluate();\n     \n+    /**\n+     * Apply the condition to the filter, further restricting the filter if\n+     * possible. This may also verify the data types are compatible, and that\n+     * paths are valid.\n+     * \n+     * @param f the filter\n+     */\n     public abstract void restrict(FilterImpl f);\n \n-    public abstract void restrictPushDown(SelectorImpl selectorImpl);\n+    /**\n+     * Push as much of the condition down to this selector, further restricting\n+     * the selector condition if possible.\n+     * \n+     * @param s the selector\n+     */\n+    public abstract void restrictPushDown(SelectorImpl s);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\nindex 6e4e408ea6..a5ab71f54d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n@@ -60,8 +60,15 @@ boolean accept(AstVisitor v) {\n \n     @Override\n     public String getPlan(NodeState rootState) {\n-        return left.getPlan(rootState) + ' ' + joinType +\n-                \" \" + right.getPlan(rootState) + \" on \" + joinCondition;\n+        StringBuilder buff = new StringBuilder();\n+        buff.append(left.getPlan(rootState)).\n+            append(' ').\n+            append(joinType).\n+            append(' ').\n+            append(right.getPlan(rootState)).\n+            append(\" on \").\n+            append(joinCondition);\n+        return buff.toString();\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\nindex 187a795efb..7ab0cbee9b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n@@ -81,6 +81,11 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             String p2 = selector2.currentPath();\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = KNOWN_PATH;\n+            }\n             if (p2 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p2, Filter.PathRestriction.EXACT);\n@@ -93,6 +98,11 @@ public void restrict(FilterImpl f) {\n         }\n         if (f.getSelector() == selector2) {\n             String p1 = selector1.currentPath();\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = KNOWN_PATH;\n+            }\n             if (p1 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p1, Filter.PathRestriction.EXACT);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex ecf1e5b705..3e779ff094 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -95,6 +95,9 @@ public String toString() {\n         return quote(nodeTypeName) + \" as \" + quote(selectorName);\n     }\n \n+    public boolean isPrepared() {\n+        return index != null;\n+    }\n \n     @Override\n     public void prepare() {\n@@ -106,19 +109,19 @@ public void prepare() {\n                 c.restrictPushDown(this);\n             }\n         }\n-        index = query.getBestIndex(createFilter());\n+        index = query.getBestIndex(createFilter(true));\n     }\n \n     @Override\n     public void execute(NodeState rootState) {\n-        cursor = index.query(createFilter(), rootState);\n+        cursor = index.query(createFilter(false), rootState);\n     }\n \n     @Override\n     public String getPlan(NodeState rootState) {\n         StringBuilder buff = new StringBuilder();\n         buff.append(toString());\n-        buff.append(\" /* \").append(index.getPlan(createFilter(), rootState));\n+        buff.append(\" /* \").append(index.getPlan(createFilter(true), rootState));\n         if (selectorCondition != null) {\n             buff.append(\" where \").append(selectorCondition);\n         }\n@@ -126,8 +129,15 @@ public String getPlan(NodeState rootState) {\n         return buff.toString();\n     }\n \n-    private Filter createFilter() {\n+    /**\n+     * Create the filter condition for planning or execution.\n+     * \n+     * @param preparing whether a filter for the prepare phase should be made \n+     * @return the filter\n+     */\n+    private Filter createFilter(boolean preparing) {\n         FilterImpl f = new FilterImpl(this, query.getStatement());\n+        f.setPreparing(preparing);\n         validateNodeType(nodeTypeName);\n         f.setNodeType(nodeTypeName);\n         if (joinCondition != null) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 9bf1ef2d6a..dc1d8e9f3f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -141,8 +141,8 @@ public SelectorImpl getExistingSelector(String selectorName) {\n     public abstract String getPlan(NodeState rootState);\n \n     /**\n-     * Prepare executing the query. This method will decide which index to use.\n-     *\n+     * Prepare executing the query (recursively). This method will decide which\n+     * index to use.\n      */\n     public abstract void prepare();\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex f540e187f0..767ea3e5ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -76,6 +76,11 @@\n      */\n     private boolean distinct;\n     \n+    /**\n+     * Set during the prepare phase of a query.\n+     */\n+    private boolean preparing;\n+\n     // TODO support \"order by\"\n \n     public FilterImpl(SelectorImpl selector, String queryStatement) {\n@@ -83,6 +88,14 @@ public FilterImpl(SelectorImpl selector, String queryStatement) {\n         this.queryStatement = queryStatement;\n     }\n     \n+    public void setPreparing(boolean preparing) {\n+        this.preparing = preparing;\n+    }\n+    \n+    public boolean isPreparing() {\n+        return preparing;\n+    }\n+\n     /**\n      * Get the path.\n      *\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}