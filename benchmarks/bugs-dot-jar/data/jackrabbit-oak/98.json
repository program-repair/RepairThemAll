{
    "bug_id": 98,
    "classification": {
        "singleLine": false
    },
    "commit": "4af0d4ee",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.segment.file.FileStoreTest"
    ],
    "files": 1,
    "jira_id": "2049",
    "linesAdd": 13,
    "linesRem": 1,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 9,
    "nb_test": 1900,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 84ac11a4bb..62811a07a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -46,6 +46,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -191,6 +192,8 @@ public synchronized void flush() {\n                     refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                     16);\n \n+            checkState(length <= buffer.length);\n+\n             int pos = refcount * 16;\n             if (pos + length <= buffer.length) {\n                 // the whole segment fits to the space *after* the referenced\n@@ -291,14 +294,23 @@ private RecordId prepare(\n             refcount -= idcount;\n \n             Set<SegmentId> segmentIds = newIdentityHashSet();\n+            \n+            // The set of old record ids in this segment\n+            // that were previously root record ids, but will no longer be,\n+            // because the record to be written references them.\n+            // This needs to be a set, because the list of ids can\n+            // potentially reference the same record multiple times\n+            Set<RecordId> notRoots = new HashSet<RecordId>();\n             for (RecordId recordId : ids) {\n                 SegmentId segmentId = recordId.getSegmentId();\n                 if (segmentId != segment.getSegmentId()) {\n                     segmentIds.add(segmentId);\n                 } else if (roots.containsKey(recordId)) {\n-                    rootcount--;\n+                    notRoots.add(recordId);\n                 }\n             }\n+            rootcount -= notRoots.size();\n+\n             if (!segmentIds.isEmpty()) {\n                 for (int refid = 1; refid < refcount; refid++) {\n                     segmentIds.remove(segment.getRefId(refid));\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}