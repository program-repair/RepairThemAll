{
    "bug_id": 147,
    "classification": {
        "singleLine": false
    },
    "commit": "a1556c30",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest"
    ],
    "files": 2,
    "jira_id": "2147",
    "linesAdd": 26,
    "linesRem": 13,
    "nb_error": 0,
    "nb_failure": 9,
    "nb_skipped": 1,
    "nb_test": 1932,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\nindex ba92511621..96f4cd3e8d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n@@ -136,12 +136,12 @@ public static boolean isAscending(NodeState indexMeta) {\n      *  <dt>lane 3:</dt> <dd>0.1%</dd>\n      * </dl>\n      */\n-    double DEFAULT_PROBABILITY = 0.1;\n+    double DEFAULT_PROBABILITY = Integer.getInteger(\"oak.orderedIndex.prob\", 3) / 10.0;\n     \n     /**\n      * the number of lanes used in the SkipList \n      */\n-    int LANES = 4;\n+    int LANES = Integer.getInteger(\"oak.orderedIndex.lanes\", 15);\n     \n     /**\n      * Convenience Predicate that will force the implementor to expose what we're searching for\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex e039c0d4de..ce158a218f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -23,6 +23,7 @@\n \n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Deque;\n import java.util.Iterator;\n@@ -51,7 +52,6 @@\n \n import com.google.common.base.Charsets;\n import com.google.common.base.Strings;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n \n@@ -867,10 +867,13 @@ String seek(@Nonnull final NodeBuilder index,\n             LOG.debug(\"seek() - plain case\");\n             \n             lane = OrderedIndex.LANES - 1;\n-            \n+            NodeBuilder currentNode = null;\n             do {\n                 stillLaning = lane > 0;\n-                nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n+                if (currentNode == null) {\n+                    currentNode = index.getChildNode(currentKey);\n+                }\n+                nextkey = getPropertyNext(currentNode, lane);\n                 if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {\n                     // if we're currently pointing to NIL or the next element does not fit the search\n                     // but we still have lanes left, let's lower the lane;\n@@ -880,6 +883,7 @@ String seek(@Nonnull final NodeBuilder index,\n                         found = nextkey;\n                     } else {\n                         currentKey = nextkey;\n+                        currentNode = null;\n                         if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                             for (int l = lane; l >= 0; l--) {\n                                 walkedLanes[l] = currentKey;\n@@ -1072,12 +1076,18 @@ public boolean hasNext() {\n      */\n     static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {\n         if (node != null && next != null) {\n-            String n1 = (next.length > 0) ? next[0] : \"\";\n-            String n2 = (next.length > 1) ? next[1] : \"\";\n-            String n3 = (next.length > 2) ? next[2] : \"\";\n-            String n4 = (next.length > 3) ? next[3] : \"\";\n-            \n-            node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);\n+            int len = next.length - 1;\n+            for (; len >= 0; len--) {\n+                if (next[len].length() != 0) {\n+               \t    break;\n+                }\n+            }\n+            len++;\n+            List<String> list = new ArrayList<String>(len);\n+            for (int i = 0; i < len; i++) {\n+                list.add(next[i]);\n+            }\n+            node.setProperty(NEXT, list, Type.STRINGS);\n         }\n     }\n     \n@@ -1102,7 +1112,7 @@ static void setPropertyNext(@Nonnull final NodeBuilder node,\n                         // content\n                         LOG.debug(\"topping-up the number of lanes.\");\n                         List<String> vv = Lists.newArrayList(values);\n-                        for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n+                        for (int i = vv.size(); i < OrderedIndex.LANES; i++) {\n                             vv.add(\"\");\n                         }\n                         values = vv.toArray(new String[vv.size()]);\n@@ -1151,7 +1161,10 @@ static String getPropertyNext(@Nonnull final NodeBuilder node, final int lane) {\n         PropertyState ps = node.getProperty(NEXT);\n         if (ps != null) {\n             if (ps.isArray()) {\n-                next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\n+                int count = ps.count();\n+                if (count > 0 && count > lane) {\n+                    next = ps.getValue(Type.STRING, lane);\n+                }\n             } else {\n                 next = ps.getValue(Type.STRING);\n             }\n",
    "project": "jackrabbit-oak"
}