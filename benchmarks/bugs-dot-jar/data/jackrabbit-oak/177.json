{
    "bug_id": 177,
    "classification": {
        "singleLine": false
    },
    "commit": "89317b28",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.document.UpdateOpTest"
    ],
    "files": 3,
    "jira_id": "3028",
    "linesAdd": 28,
    "linesRem": 13,
    "nb_error": 0,
    "nb_failure": 3,
    "nb_skipped": 9,
    "nb_test": 2190,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex a76466969d..7f09df6882 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -383,7 +383,7 @@ private void applyToDocumentStore(Revision baseBranchRevision) {\n                     // to set isNew to false. If we get here the\n                     // commitRoot document already exists and\n                     // only needs an update\n-                    UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\n+                    UpdateOp commit = commitRoot.copy();\n                     commit.setNew(false);\n                     // only set revision on commit root when there is\n                     // no collision for this commit revision\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 3455f4be4c..65f79f3595 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1170,13 +1170,11 @@ void revisionsMerged(@Nonnull Iterable<Revision> revisions) {\n     @CheckForNull\n     NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n         // use batch commit when there are only revision and modified updates\n-        // and collision checks\n         boolean batch = true;\n         for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n             String name = op.getKey().getName();\n             if (NodeDocument.isRevisionsEntry(name)\n-                    || NodeDocument.MODIFIED_IN_SECS.equals(name)\n-                    || NodeDocument.COLLISIONS.equals(name)) {\n+                    || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\n                 continue;\n             }\n             batch = false;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f72a7ae4fb..0196878119 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -50,23 +50,32 @@\n      * @param isNew whether this is a new document\n      */\n     UpdateOp(String id, boolean isNew) {\n-        this(id, isNew, false, new HashMap<Key, Operation>());\n+        this(id, isNew, false, new HashMap<Key, Operation>(), null);\n     }\n \n-    private UpdateOp(String id, boolean isNew, boolean isDelete,\n-                     Map<Key, Operation> changes) {\n-        this.id = id;\n+    private UpdateOp(@Nonnull String id, boolean isNew, boolean isDelete,\n+                     @Nonnull Map<Key, Operation> changes,\n+                     @Nullable Map<Key, Condition> conditions) {\n+        this.id = checkNotNull(id);\n         this.isNew = isNew;\n         this.isDelete = isDelete;\n-        this.changes = changes;\n+        this.changes = checkNotNull(changes);\n+        this.conditions = conditions;\n     }\n \n     static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n         Map<Key, Operation> changes = Maps.newHashMap();\n+        Map<Key, Condition> conditions = Maps.newHashMap();\n         for (UpdateOp op : ops) {\n             changes.putAll(op.getChanges());\n+            if (op.conditions != null) {\n+                conditions.putAll(op.conditions);\n             }\n-        return new UpdateOp(id, false, false, changes);\n+        }\n+        if (conditions.isEmpty()) {\n+            conditions = null;\n+        }\n+        return new UpdateOp(id, false, false, changes, conditions);\n     }\n \n     /**\n@@ -76,7 +85,7 @@ static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n      * @param id the primary key.\n      */\n     public UpdateOp shallowCopy(String id) {\n-        return new UpdateOp(id, isNew, isDelete, changes);\n+        return new UpdateOp(id, isNew, isDelete, changes, conditions);\n     }\n \n     /**\n@@ -86,8 +95,12 @@ public UpdateOp shallowCopy(String id) {\n      * @return a copy of this operation.\n      */\n     public UpdateOp copy() {\n+        Map<Key, Condition> conditionMap = null;\n+        if (conditions != null) {\n+            conditionMap = new HashMap<Key, Condition>(conditions);\n+        }\n         return new UpdateOp(id, isNew, isDelete,\n-                new HashMap<Key, Operation>(changes));\n+                new HashMap<Key, Operation>(changes), conditionMap);\n     }\n \n     public String getId() {\n@@ -254,7 +267,11 @@ public UpdateOp getReverseOperation() {\n \n     @Override\n     public String toString() {\n-        return \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        String s = \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        if (conditions != null) {\n+            s += \" conditions \" + conditions;\n+        }\n+        return s;\n     }\n \n     private Map<Key, Condition> getOrCreateConditions() {\n",
    "project": "jackrabbit-oak"
}