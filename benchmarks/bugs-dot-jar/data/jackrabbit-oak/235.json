{
    "bug_id": 235,
    "classification": {
        "singleLine": false
    },
    "commit": "9a109aa3",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.lucene.SuggestionIntervalTest"
    ],
    "files": 1,
    "jira_id": "4066",
    "linesAdd": 65,
    "linesRem": 21,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 6,
    "nb_test": 354,
    "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex c49902cdb2..fb79cc774e 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -245,6 +245,12 @@ void closeWriter() throws IOException {\n             getWriter();\n         }\n \n+        boolean updateSuggestions = shouldUpdateSuggestions();\n+        if (writer == null && updateSuggestions) {\n+            log.debug(\"Would update suggester dictionary although no index changes were detected in current cycle\");\n+            getWriter();\n+        }\n+\n         if (writer != null) {\n             if (log.isTraceEnabled()) {\n                 trackIndexSizeInfo(writer, definition, directory);\n@@ -252,8 +258,14 @@ void closeWriter() throws IOException {\n \n             final long start = PERF_LOGGER.start();\n \n-            updateSuggester(writer.getAnalyzer());\n+            Calendar lastUpdated = null;\n+            if (updateSuggestions) {\n+                lastUpdated = updateSuggester(writer.getAnalyzer());\n                 PERF_LOGGER.end(start, -1, \"Completed suggester for directory {}\", definition);\n+            }\n+            if (lastUpdated == null) {\n+                lastUpdated = getCalendar();\n+            }\n \n             writer.close();\n             PERF_LOGGER.end(start, -1, \"Closed writer for directory {}\", definition);\n@@ -265,8 +277,9 @@ void closeWriter() throws IOException {\n             //as to make IndexTracker detect changes when index\n             //is stored in file system\n             NodeBuilder status = definitionBuilder.child(\":status\");\n-            status.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            status.setProperty(\"lastUpdated\", ISO8601.format(lastUpdated), Type.DATE);\n             status.setProperty(\"indexedNodes\", indexedNodes);\n+\n             PERF_LOGGER.end(start, -1, \"Overall Closed IndexWriter for directory {}\", definition);\n \n             textExtractionStats.log(reindex);\n@@ -278,38 +291,69 @@ void closeWriter() throws IOException {\n      * eventually update suggest dictionary\n      * @throws IOException if suggest dictionary update fails\n      * @param analyzer the analyzer used to update the suggester\n+     * @return {@link Calendar} object representing the lastUpdated value written by suggestions\n      */\n-    private void updateSuggester(Analyzer analyzer) throws IOException {\n-\n-        if (definition.isSuggestEnabled()) {\n-\n-            boolean updateSuggester = false;\n+    private Calendar updateSuggester(Analyzer analyzer) throws IOException {\n+        Calendar ret = null;\n         NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n-            if (suggesterStatus.hasProperty(\"lastUpdated\")) {\n-                PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n-                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n-                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n-                suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);\n-                if (getCalendar().after(suggesterLastUpdatedTime)) {\n-                    updateSuggester = true;\n-                }\n-            } else {\n-                updateSuggester = true;\n-            }\n-\n-            if (updateSuggester) {\n         DirectoryReader reader = DirectoryReader.open(writer, false);\n         final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, \":suggest-data\", definition, false);\n         try {\n             SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);\n-                    suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            ret = getCalendar();\n+            suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(ret), Type.DATE);\n         } catch (Throwable e) {\n             log.warn(\"could not update suggester\", e);\n         } finally {\n             suggestDirectory.close();\n             reader.close();\n         }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Checks if last suggestion build time was done sufficiently in the past AND that there were non-zero indexedNodes\n+     * stored in the last run. Note, if index is updated only to rebuild suggestions, even then we update indexedNodes,\n+     * which would be zero in case it was a forced update of suggestions.\n+     * @return is suggest dict should be updated\n+     */\n+    private boolean shouldUpdateSuggestions() {\n+        boolean updateSuggestions = false;\n+\n+        if (definition.isSuggestEnabled()) {\n+            NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n+\n+            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n+\n+            if (suggesterLastUpdatedValue != null) {\n+                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n+\n+                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n+                Calendar nextSuggestUpdateTime = (Calendar)suggesterLastUpdatedTime.clone();\n+                nextSuggestUpdateTime.add(Calendar.MINUTE, updateFrequency);\n+                if (getCalendar().after(nextSuggestUpdateTime)) {\n+                    updateSuggestions = (writer != null || isIndexUpdatedAfter(suggesterLastUpdatedTime));\n+                }\n+            } else {\n+                updateSuggestions = true;\n+            }\n+        }\n+\n+        return updateSuggestions;\n     }\n+\n+    /**\n+     * @return {@code false} if persisted lastUpdated time for index is after {@code calendar}. {@code true} otherwise\n+     */\n+    private boolean isIndexUpdatedAfter(Calendar calendar) {\n+        NodeBuilder indexStats = definitionBuilder.child(\":status\");\n+        PropertyState indexLastUpdatedValue = indexStats.getProperty(\"lastUpdated\");\n+        if (indexLastUpdatedValue != null) {\n+            Calendar indexLastUpdatedTime = ISO8601.parse(indexLastUpdatedValue.getValue(Type.DATE));\n+            return indexLastUpdatedTime.after(calendar);\n+        } else {\n+            return true;\n         }\n     }\n \n",
    "project": "jackrabbit-oak"
}