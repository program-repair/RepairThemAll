{
    "bug_id": 229,
    "classification": {
        "singleLine": false
    },
    "commit": "dcadb0e1",
    "failing_tests": [
        "org.apache.jackrabbit.oak.jcr.xml.ImportTest"
    ],
    "files": 1,
    "jira_id": "2246",
    "linesAdd": 79,
    "linesRem": 53,
    "nb_error": 3,
    "nb_failure": 2,
    "nb_skipped": 1,
    "nb_test": 1351,
    "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\nindex 176dffe333..8e7e72f0a8 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n@@ -47,6 +47,7 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import org.apache.jackrabbit.JcrConstants;\n+import org.apache.jackrabbit.oak.api.ContentSession;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Root;\n import org.apache.jackrabbit.oak.api.Tree;\n@@ -82,26 +83,10 @@\n     private final String userID;\n     private final AccessManager accessManager;\n \n-    /**\n-     * There are two IdentifierManagers used.\n-     *\n-     * 1) currentStateIdManager - Associated with current root on which all import\n-     *    operations are being performed\n-     *\n-     * 2) baseStateIdManager - Associated with the initial root on which\n-     *    no modifications are performed\n-     */\n-    private final IdentifierManager currentStateIdManager;\n-    private final IdentifierManager baseStateIdManager;\n-\n     private final EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n     private final DefinitionProvider definitionProvider;\n \n-    /**\n-     * Set of newly created uuid from nodes which are\n-     * created in this import\n-     */\n-    private final Set<String> uuids = new HashSet<String>();\n+    private final IdResolver idLookup;\n \n     private final Stack<Tree> parents;\n \n@@ -171,8 +156,7 @@ public ImporterImpl(String absPath,\n \n         accessManager = sessionContext.getAccessManager();\n \n-        currentStateIdManager = new IdentifierManager(root);\n-        baseStateIdManager = new IdentifierManager(sd.getContentSession().getLatestRoot());\n+        idLookup = new IdResolver(root, sd.getContentSession());\n \n         refTracker = new ReferenceChangeTracker();\n \n@@ -465,24 +449,7 @@ public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n                 }\n             } else {\n \n-                //1. First check from base state that tree corresponding to\n-                //this id exist\n-                Tree conflicting = baseStateIdManager.getTree(id);\n-\n-                if (conflicting == null) {\n-                    //1.a. Check if id is found in newly created nodes\n-                    if (uuids.contains(id)) {\n-                        conflicting = currentStateIdManager.getTree(id);\n-                    }\n-                } else {\n-                    //1.b Re obtain the conflicting tree from Id Manager\n-                    //associated with current root. Such that any operation\n-                    //on it gets reflected in later operations\n-                    //In case a tree with same id was removed earlier then it\n-                    //would return null\n-                    conflicting = currentStateIdManager.getTree(id);\n-                }\n-\n+                Tree conflicting = idLookup.getConflictingTree(id);\n                 if (conflicting != null && conflicting.exists()) {\n                     // resolve uuid conflict\n                     tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n@@ -522,22 +489,7 @@ public void endNode(NodeInfo nodeInfo) throws RepositoryException {\n             }\n         }\n \n-        collectUUIDs(parent);\n-    }\n-\n-    private void collectUUIDs(Tree tree) {\n-        if (tree == null) {\n-            return;\n-        }\n-\n-        String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n-        if (uuid != null) {\n-            uuids.add(uuid);\n-        }\n-\n-        for (Tree child : tree.getChildren()) {\n-            collectUUIDs(child);\n-        }\n+        idLookup.rememberImportedUUIDs(parent);\n     }\n \n     @Override\n@@ -621,4 +573,78 @@ private void setProperty(Iterable<String> newValues) {\n             tree.setProperty(prop);\n         }\n     }\n+\n+    /**\n+     * Resolves 'uuid' property values to {@code Tree} objects and optionally\n+     * keeps track of newly imported UUIDs.\n+     */\n+    private static final class IdResolver {\n+        /**\n+         * There are two IdentifierManagers used.\n+         *\n+         * 1) currentStateIdManager - Associated with current root on which all import\n+         *    operations are being performed\n+         *\n+         * 2) baseStateIdManager - Associated with the initial root on which\n+         *    no modifications are performed\n+         */\n+        private final IdentifierManager currentStateIdManager;\n+        private final IdentifierManager baseStateIdManager;\n+\n+        /**\n+         * Set of newly created uuid from nodes which are\n+         * created in this import, which are only remembered if the editing\n+         * session doesn't have any pending transient changes preventing this\n+         * performance optimisation from working properly (see OAK-2246).\n+         */\n+        private final Set<String> importedUUIDs;\n+\n+        private IdResolver(@Nonnull Root root, @Nonnull ContentSession contentSession) {\n+            currentStateIdManager = new IdentifierManager(root);\n+            baseStateIdManager = new IdentifierManager(contentSession.getLatestRoot());\n+\n+            if (!root.hasPendingChanges()) {\n+                importedUUIDs = new HashSet<String>();\n+            } else {\n+                importedUUIDs = null;\n+            }\n+        }\n+\n+\n+        @CheckForNull\n+        private Tree getConflictingTree(@Nonnull String id) {\n+            //1. First check from base state that tree corresponding to\n+            //this id exist\n+            Tree conflicting = baseStateIdManager.getTree(id);\n+            if (conflicting == null && importedUUIDs != null) {\n+                //1.a. Check if id is found in newly created nodes\n+                if (importedUUIDs.contains(id)) {\n+                    conflicting = currentStateIdManager.getTree(id);\n+                }\n+            } else {\n+                //1.b Re obtain the conflicting tree from Id Manager\n+                //associated with current root. Such that any operation\n+                //on it gets reflected in later operations\n+                //In case a tree with same id was removed earlier then it\n+                //would return null\n+                conflicting = currentStateIdManager.getTree(id);\n+            }\n+            return conflicting;\n+        }\n+\n+        private void rememberImportedUUIDs(@CheckForNull Tree tree) {\n+            if (tree == null || importedUUIDs == null) {\n+                return;\n+            }\n+\n+            String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n+            if (uuid != null) {\n+                importedUUIDs.add(uuid);\n+            }\n+\n+            for (Tree child : tree.getChildren()) {\n+                rememberImportedUUIDs(child);\n+            }\n+        }\n+    }\n }\n",
    "project": "jackrabbit-oak"
}