{
    "bug_id": 158,
    "classification": {
        "singleLine": false
    },
    "commit": "00b4b8a0",
    "failing_tests": [
        "org.apache.jackrabbit.oak.core.RootImplTest",
        "org.apache.jackrabbit.oak.core.TreeImplTest"
    ],
    "files": 1,
    "jira_id": "621",
    "linesAdd": 42,
    "linesRem": 44,
    "nb_error": 0,
    "nb_failure": 2,
    "nb_skipped": 8,
    "nb_test": 619,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 3cbd5b8d9c..ac0353adbf 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -57,6 +57,11 @@\n      */\n     private final RootImpl root;\n \n+    /**\n+     * The {@code NodeBuilder} for the underlying node state\n+     */\n+    private final NodeBuilder nodeBuilder;\n+\n     /**\n      * Parent of this tree. Null for the root.\n      */\n@@ -67,32 +72,26 @@\n      */\n     private String name;\n \n-    /**\n-     * Lazily initialised {@code NodeBuilder} for the underlying node state\n-     */\n-    NodeBuilder nodeBuilder;\n+    private TreeImpl(RootImpl root) {\n+        this.root = checkNotNull(root);\n+        this.name = \"\";\n+        this.nodeBuilder = root.createRootBuilder();\n+    }\n \n     private TreeImpl(RootImpl root, TreeImpl parent, String name) {\n         this.root = checkNotNull(root);\n-        this.parent = parent;\n+        this.parent = checkNotNull(parent);\n         this.name = checkNotNull(name);\n+        this.nodeBuilder = parent.getNodeBuilder().child(name);\n     }\n \n     @Nonnull\n     static TreeImpl createRoot(final RootImpl root) {\n-        return new TreeImpl(root, null, \"\") {\n+        return new TreeImpl(root) {\n             @Override\n             protected NodeState getBaseState() {\n                 return root.getBaseState();\n             }\n-\n-            @Override\n-            protected synchronized NodeBuilder getNodeBuilder() {\n-                if (nodeBuilder == null) {\n-                    nodeBuilder = root.createRootBuilder();\n-                }\n-                return nodeBuilder;\n-            }\n         };\n     }\n \n@@ -189,7 +188,7 @@ public long getPropertyCount() {\n     @Override\n     public Iterable<? extends PropertyState> getProperties() {\n         root.checkLive();\n-        return Iterables.filter(getNodeBuilder().getProperties(),\n+        return Iterables.filter(nodeBuilder.getProperties(),\n                 new Predicate<PropertyState>() {\n                     @Override\n                     public boolean apply(PropertyState propertyState) {\n@@ -219,7 +218,7 @@ private boolean isDisconnected() {\n         if (!parent.nodeBuilder.isConnected()) {\n             return true;\n         }\n-        return !getNodeBuilder().isConnected();\n+        return !nodeBuilder.isConnected();\n     }\n \n     @Override\n@@ -230,7 +229,7 @@ public Status getStatus() {\n             return Status.DISCONNECTED;\n         }\n \n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         if (builder.isNew()) {\n             return Status.NEW;\n         } else if (builder.isModified()) {\n@@ -250,7 +249,7 @@ public boolean hasChild(String name) {\n     public long getChildrenCount() {\n         // TODO: make sure cnt respects access control\n         root.checkLive();\n-        return getNodeBuilder().getChildNodeCount();\n+        return nodeBuilder.getChildNodeCount();\n     }\n \n     @Override\n@@ -260,7 +259,7 @@ public long getChildrenCount() {\n         if (hasOrderableChildren()) {\n             childNames = getOrderedChildNames();\n         } else {\n-            childNames = getNodeBuilder().getChildNodeNames();\n+            childNames = nodeBuilder.getChildNodeNames();\n         }\n         return Iterables.filter(Iterables.transform(\n                 childNames,\n@@ -282,9 +281,9 @@ public boolean apply(Tree tree) {\n     public Tree addChild(String name) {\n         root.checkLive();\n         if (!hasChild(name)) {\n-            getNodeBuilder().child(name);\n+            nodeBuilder.child(name);\n             if (hasOrderableChildren()) {\n-                getNodeBuilder().setProperty(\n+                nodeBuilder.setProperty(\n                         MemoryPropertyBuilder.copy(Type.STRING, internalGetProperty(OAK_CHILD_ORDER))\n                                 .addValue(name)\n                                 .getPropertyState());\n@@ -292,8 +291,10 @@ public Tree addChild(String name) {\n             root.updated();\n         }\n \n-        TreeImpl child = getChild(name);\n-        assert child != null;\n+        TreeImpl child = new TreeImpl(root, this, name);\n+\n+        // Make sure to allocate the node builder for new nodes in order to correctly\n+        // track removes and moves. See OAK-621\n         return child;\n     }\n \n@@ -305,7 +306,7 @@ public boolean remove() {\n         }\n \n         if (!isRoot() && parent.hasChild(name)) {\n-            NodeBuilder builder = parent.getNodeBuilder();\n+            NodeBuilder builder = parent.nodeBuilder;\n             builder.removeNode(name);\n             if (parent.hasOrderableChildren()) {\n                 builder.setProperty(\n@@ -360,7 +361,7 @@ public boolean apply(@Nullable String input) {\n             tail = Iterables.skip(filtered, idx);\n         }\n         // concatenate head, this name and tail\n-        parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n+        parent.nodeBuilder.setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n         );\n         root.updated();\n         return true;\n@@ -369,7 +370,7 @@ public boolean apply(@Nullable String input) {\n     @Override\n     public void setProperty(PropertyState property) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(property);\n         root.updated();\n     }\n@@ -377,7 +378,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value);\n         root.updated();\n     }\n@@ -385,7 +386,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value, Type<T> type) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value, type);\n         root.updated();\n     }\n@@ -393,7 +394,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public void removeProperty(String name) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.removeProperty(name);\n         root.updated();\n     }\n@@ -418,16 +419,13 @@ protected NodeState getBaseState() {\n                 : parentBaseState.getChildNode(name);\n     }\n \n+    //-----------------------------------------------------------< internal >---\n+\n     @Nonnull\n-    protected synchronized NodeBuilder getNodeBuilder() {\n-        if (nodeBuilder == null) {\n-            nodeBuilder = parent.getNodeBuilder().child(name);\n-        }\n+    NodeBuilder getNodeBuilder() {\n         return nodeBuilder;\n     }\n \n-    //-----------------------------------------------------------< internal >---\n-\n     /**\n      * Move this tree to the parent at {@code destParent} with the new name\n      * {@code destName}.\n@@ -446,7 +444,7 @@ void moveTo(TreeImpl destParent, String destName) {\n \n     @Nonnull\n     NodeState getNodeState() {\n-        return getNodeBuilder().getNodeState();\n+        return nodeBuilder.getNodeState();\n     }\n \n     /**\n@@ -480,29 +478,29 @@ void updateChildOrder() {\n         }\n         Set<String> names = Sets.newLinkedHashSet();\n         for (String name : getOrderedChildNames()) {\n-            if (getNodeBuilder().hasChildNode(name)) {\n+            if (nodeBuilder.hasChildNode(name)) {\n                 names.add(name);\n             }\n         }\n-        for (String name : getNodeBuilder().getChildNodeNames()) {\n+        for (String name : nodeBuilder.getChildNodeNames()) {\n             names.add(name);\n         }\n         PropertyBuilder<String> builder = MemoryPropertyBuilder.array(\n                 Type.STRING, OAK_CHILD_ORDER);\n         builder.setValues(names);\n-        getNodeBuilder().setProperty(builder.getPropertyState());\n+        nodeBuilder.setProperty(builder.getPropertyState());\n     }\n \n     //------------------------------------------------------------< private >---\n \n     private TreeImpl internalGetChild(String childName) {\n-        return getNodeBuilder().hasChildNode(childName)\n+        return nodeBuilder.hasChildNode(childName)\n                 ? new TreeImpl(root, this, childName)\n                 : null;\n     }\n \n     private PropertyState internalGetProperty(String propertyName) {\n-        return getNodeBuilder().getProperty(propertyName);\n+        return nodeBuilder.getProperty(propertyName);\n     }\n \n     private void buildPath(StringBuilder sb) {\n@@ -574,10 +572,10 @@ public void remove() {\n      * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.\n      */\n     public void ensureChildOrderProperty() {\n-        PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);\n+        PropertyState childOrder = nodeBuilder.getProperty(OAK_CHILD_ORDER);\n         if (childOrder == null) {\n-            getNodeBuilder().setProperty(\n-                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));\n+            nodeBuilder.setProperty(\n+                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));\n         }\n     }\n \n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}