{
    "bug_id": 17,
    "classification": {
        "singleLine": false
    },
    "commit": "63070cf9",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexExclusionQueryTest"
    ],
    "files": 1,
    "jira_id": "1668",
    "linesAdd": 56,
    "linesRem": 12,
    "nb_error": 0,
    "nb_failure": 2,
    "nb_skipped": 0,
    "nb_test": 257,
    "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 6d8e111a69..c589260f6f 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -28,6 +28,8 @@\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH_SELECTOR;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.EXCLUDE_PROPERTY_NAMES;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INCLUDE_PROPERTY_TYPES;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INDEX_DATA_CHILD_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_FILE;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_NAME;\n@@ -56,6 +58,8 @@\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import javax.jcr.PropertyType;\n+\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.plugins.index.aggregate.NodeAggregator;\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.MoreLikeThisHelper;\n@@ -67,11 +71,11 @@\n import org.apache.jackrabbit.oak.query.fulltext.FullTextTerm;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n-import org.apache.jackrabbit.oak.spi.query.Filter;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.Cursors.PathCursor;\n+import org.apache.jackrabbit.oak.spi.query.Filter;\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.IndexRow;\n+import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.FulltextQueryIndex;\n import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\n@@ -329,7 +333,7 @@ public String getPlan(Filter filter, NodeState root) {\n         // we only restrict non-full-text conditions if there is\n         // no relative property in the full-text constraint\n         boolean nonFullTextConstraints = parent.isEmpty();\n-        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + \" ft:(\" + ft + \")\";\n+        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer, getIndexDef(root)) + \" ft:(\" + ft + \")\";\n         if (!parent.isEmpty()) {\n             plan += \" parent:\" + parent;\n         }\n@@ -363,7 +367,7 @@ public Cursor query(Filter filter, NodeState root) {\n                     IndexSearcher searcher = new IndexSearcher(reader);\n                     List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\n                     Query query = getQuery(filter, reader,\n-                            nonFullTextConstraints, analyzer);\n+                            nonFullTextConstraints, analyzer, getIndexDef(root));\n \n                     // TODO OAK-828\n                     HashSet<String> seenPaths = new HashSet<String>();\n@@ -428,10 +432,11 @@ public Cursor query(Filter filter, NodeState root) {\n      *            path, node type, and so on) should be added to the Lucene\n      *            query\n      * @param analyzer the Lucene analyzer used for building the fulltext query\n+     * @param indexDefinition nodestate that contains the index definition\n      * @return the Lucene query\n      */\n     private static Query getQuery(Filter filter, IndexReader reader,\n-            boolean nonFullTextConstraints, Analyzer analyzer) {\n+            boolean nonFullTextConstraints, Analyzer analyzer, NodeState indexDefinition) {\n         List<Query> qs = new ArrayList<Query>();\n         FullTextExpression ft = filter.getFullTextConstraint();\n         if (ft == null) {\n@@ -461,9 +466,9 @@ private static Query getQuery(Filter filter, IndexReader reader,\n                     throw new RuntimeException(e);\n                 }\n             }\n-        }\n-        else if (nonFullTextConstraints) {\n-            addNonFullTextConstraints(qs, filter, reader, analyzer);\n+        } else if (nonFullTextConstraints) {\n+            addNonFullTextConstraints(qs, filter, reader, analyzer,\n+                    indexDefinition);\n         }\n         if (qs.size() == 0) {\n             return new MatchAllDocsQuery();\n@@ -479,7 +484,7 @@ else if (nonFullTextConstraints) {\n     }\n \n     private static void addNonFullTextConstraints(List<Query> qs,\n-            Filter filter, IndexReader reader, Analyzer analyzer) {\n+            Filter filter, IndexReader reader, Analyzer analyzer, NodeState indexDefinition) {\n         if (!filter.matchesAllTypes()) {\n             addNodeTypeConstraints(qs, filter);\n         }\n@@ -526,11 +531,12 @@ private static void addNonFullTextConstraints(List<Query> qs,\n                 continue;\n             }\n \n-            String name = pr.propertyName;\n-            if (name.contains(\"/\")) {\n-                // lucene cannot handle child-level property restrictions\n+            // check excluded properties and types\n+            if (isExcludedProperty(pr, indexDefinition)) {\n                 continue;\n             }\n+\n+            String name = pr.propertyName;\n             if (\"rep:excerpt\".equals(name)) {\n                 continue;\n             }\n@@ -617,6 +623,44 @@ private static String tokenizeAndPoll(String token, Analyzer analyzer){\n         return token;\n     }\n \n+    private static boolean isExcludedProperty(PropertyRestriction pr,\n+            NodeState definition) {\n+        String name = pr.propertyName;\n+        if (name.contains(\"/\")) {\n+            // lucene cannot handle child-level property restrictions\n+            return true;\n+        }\n+\n+        // check name\n+        for (String e : definition.getStrings(EXCLUDE_PROPERTY_NAMES)) {\n+            if (e.equalsIgnoreCase(name)) {\n+                return true;\n+            }\n+        }\n+\n+        // check type\n+        Integer type = null;\n+        if (pr.first != null) {\n+            type = pr.first.getType().tag();\n+        } else if (pr.last != null) {\n+            type = pr.last.getType().tag();\n+        } else if (pr.list != null && !pr.list.isEmpty()) {\n+            type = pr.list.get(0).getType().tag();\n+        }\n+        if (type != null) {\n+            boolean isIn = false;\n+            for (String e : definition.getStrings(INCLUDE_PROPERTY_TYPES)) {\n+                if (PropertyType.valueFromName(e) == type) {\n+                    isIn = true;\n+                }\n+            }\n+            if (!isIn) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static void addReferenceConstraint(String uuid, List<Query> qs,\n             IndexReader reader) {\n         if (reader == null) {\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}