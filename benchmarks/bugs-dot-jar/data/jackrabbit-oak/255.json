{
    "bug_id": 255,
    "classification": {
        "singleLine": false
    },
    "commit": "239de7b8",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
    ],
    "files": 1,
    "jira_id": "2528",
    "linesAdd": 30,
    "linesRem": 12,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 9,
    "nb_test": 1951,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex 3ca3e0840d..f6bbb19b77 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -21,7 +21,6 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.NavigableMap;\n@@ -65,6 +64,7 @@\n class SplitOperations {\n \n     private static final Logger LOG = LoggerFactory.getLogger(SplitOperations.class);\n+    private static final int GARBAGE_LIMIT = Integer.getInteger(\"oak.documentMK.garbage.limit\", 10000);\n     private static final DocumentStore STORE = new MemoryDocumentStore();\n \n     private final NodeDocument doc;\n@@ -75,7 +75,9 @@\n     private Revision low;\n     private int numValues;\n     private Map<String, NavigableMap<Revision, String>> committedChanges;\n+    private Set<Revision> changes;\n     private Map<String, Set<Revision>> garbage;\n+    private int garbageCount = 0;\n     private Set<Revision> mostRecentRevs;\n     private Set<Revision> splitRevs;\n     private List<UpdateOp> splitOps;\n@@ -119,7 +121,10 @@ private SplitOperations(@Nonnull NodeDocument doc,\n         mostRecentRevs = Sets.newHashSet();\n         splitRevs = Sets.newHashSet();\n         garbage = Maps.newHashMap();\n-        committedChanges = getCommittedLocalChanges();\n+        changes = Sets.newHashSet();\n+        committedChanges = Maps.newHashMap();\n+        \n+        collectLocalChanges(committedChanges, changes);\n \n         // revisions of the most recent committed changes on this document\n         // these are kept in the main document. _revisions and _commitRoot\n@@ -215,9 +220,15 @@ private void collectRevisionsAndCommitRoot() {\n         NavigableMap<Revision, String> commitRoot =\n                 new TreeMap<Revision, String>(context.getRevisionComparator());\n         for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n-            if (splitRevs.contains(entry.getKey())) {\n-                commitRoot.put(entry.getKey(), entry.getValue());\n+            Revision r = entry.getKey();\n+            if (splitRevs.contains(r)) {\n+                commitRoot.put(r, entry.getValue());\n                 numValues++;\n+            } else if (r.getClusterId() == context.getClusterId() \n+                    && !changes.contains(r)) {\n+                // OAK-2528: _commitRoot entry without associated\n+                // change -> consider as garbage\n+                addGarbage(r, COMMIT_ROOT);\n             }\n         }\n         committedChanges.put(COMMIT_ROOT, commitRoot);\n@@ -350,15 +361,15 @@ private UpdateOp createSplitOps() {\n     }\n \n     /**\n-     * Returns a map of all local property changes committed by the current\n+     * Collects all local property changes committed by the current\n      * cluster node.\n      *\n-     * @return local changes committed by the current cluster node.\n+     * @param committedLocally local changes committed by the current cluster node.\n+     * @param changes all revisions of local changes (committed and uncommitted).\n      */\n-    @Nonnull\n-    private Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {\n-        Map<String, NavigableMap<Revision, String>> committedLocally\n-                = new HashMap<String, NavigableMap<Revision, String>>();\n+    private void collectLocalChanges(\n+            Map<String, NavigableMap<Revision, String>> committedLocally,\n+            Set<Revision> changes) {\n         for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n             NavigableMap<Revision, String> splitMap\n                     = new TreeMap<Revision, String>(context.getRevisionComparator());\n@@ -370,6 +381,7 @@ private UpdateOp createSplitOps() {\n                 if (rev.getClusterId() != context.getClusterId()) {\n                     continue;\n                 }\n+                changes.add(rev);\n                 if (doc.isCommitted(rev)) {\n                     splitMap.put(rev, entry.getValue());\n                 } else if (isGarbage(rev)) {\n@@ -377,7 +389,6 @@ private UpdateOp createSplitOps() {\n                 }\n             }\n         }\n-        return committedLocally;\n     }\n     \n     private boolean isGarbage(Revision rev) {\n@@ -392,12 +403,17 @@ private boolean isGarbage(Revision rev) {\n     }\n     \n     private void addGarbage(Revision rev, String property) {\n+        if (garbageCount > GARBAGE_LIMIT) {\n+            return;\n+        }\n         Set<Revision> revisions = garbage.get(property);\n         if (revisions == null) {\n             revisions = Sets.newHashSet();\n             garbage.put(property, revisions);\n         }\n-        revisions.add(rev);\n+        if (revisions.add(rev)) {\n+            garbageCount++;\n+        }\n     }\n \n     private void disconnectStalePrevDocs() {\n@@ -444,11 +460,13 @@ private void removeGarbage() {\n         for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {\n             for (Revision r : entry.getValue()) {\n                 main.removeMapEntry(entry.getKey(), r);\n+                if (PROPERTY_OR_DELETED.apply(entry.getKey())) {\n                     NodeDocument.removeCommitRoot(main, r);\n                     NodeDocument.removeRevision(main, r);\n                 }\n             }\n         }\n+    }\n \n     private void trackHigh(Revision r) {\n         if (high == null || isRevisionNewer(context, r, high)) {\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}