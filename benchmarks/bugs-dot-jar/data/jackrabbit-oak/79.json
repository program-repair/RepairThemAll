{
    "bug_id": 79,
    "classification": {
        "singleLine": false
    },
    "commit": "e1ae968c",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.mongomk.DocumentSplitTest"
    ],
    "files": 1,
    "jira_id": "926",
    "linesAdd": 29,
    "linesRem": 30,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 8,
    "nb_test": 1253,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\nindex 9b6835f23b..dfe473d6f0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n@@ -118,6 +118,11 @@\n \n     final DocumentStore store;\n \n+    /**\n+     * Parsed and sorted set of previous revisions.\n+     */\n+    private SortedMap<Revision, Range> previous;\n+\n     private final long time = System.currentTimeMillis();\n \n     NodeDocument(@Nonnull DocumentStore store) {\n@@ -151,19 +156,23 @@ public final long getCreated() {\n \n     /**\n      * Returns <code>true</code> if the given <code>revision</code> is marked\n-     * committed in <strong>this</strong> document including previous documents.\n+     * committed.\n      *\n      * @param revision the revision.\n      * @return <code>true</code> if committed; <code>false</code> otherwise.\n      */\n     public boolean isCommitted(@Nonnull Revision revision) {\n+        NodeDocument commitRootDoc = getCommitRoot(checkNotNull(revision));\n+        if (commitRootDoc == null) {\n+            return false;\n+        }\n         String rev = checkNotNull(revision).toString();\n-        String value = getLocalRevisions().get(rev);\n+        String value = commitRootDoc.getLocalRevisions().get(rev);\n         if (value != null) {\n             return Utils.isCommitted(value);\n         }\n         // check previous docs\n-        for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {\n+        for (NodeDocument prev : commitRootDoc.getPreviousDocs(revision, REVISIONS)) {\n             if (prev.containsRevision(revision)) {\n                 return prev.isCommitted(revision);\n             }\n@@ -659,20 +668,26 @@ public boolean isConflicting(@Nonnull UpdateOp op,\n                     main.removeMapEntry(property, r);\n                     old.setMapEntry(property, r, entry.getValue());\n                 }\n+            }\n             splitOps.add(old);\n             splitOps.add(main);\n         }\n-        }\n         return splitOps;\n     }\n \n-    @Override\n+    /**\n+     * Returns previous revision ranges for this document. The revision keys are\n+     * sorted descending, newest first!\n+     *\n+     * @return the previous ranges for this document.\n+     */\n     @Nonnull\n-    protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map,\n-                                         @Nullable String key,\n-                                         int level) {\n-        if (level == 1) {\n-            if (PREVIOUS.equals(key)) {\n+    SortedMap<Revision, Range> getPreviousRanges() {\n+        if (previous == null) {\n+            Map<String, String> map = getLocalMap(PREVIOUS);\n+            if (map.isEmpty()) {\n+                previous = EMPTY_RANGE_MAP;\n+            } else {\n                 SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(\n                         new Comparator<Revision>() {\n                             @Override\n@@ -687,29 +702,13 @@ public int compare(Revision o1, Revision o2) {\n                                 return c;\n                             }\n                         });\n-                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n-                    Revision high = Revision.fromString(entry.getKey().toString());\n-                    Revision low = Revision.fromString(entry.getValue().toString());\n+                for (Map.Entry<String, String> entry : map.entrySet()) {\n+                    Revision high = Revision.fromString(entry.getKey());\n+                    Revision low = Revision.fromString(entry.getValue());\n                     transformed.put(high, new Range(high, low));\n                 }\n-                return Collections.unmodifiableSortedMap(transformed);\n-            }\n-        }\n-        return super.transformAndSeal(map, key, level);\n+                previous = Collections.unmodifiableSortedMap(transformed);\n             }\n-\n-    /**\n-     * Returns previous revision ranges for this document. The revision keys are\n-     * sorted descending, newest first!\n-     *\n-     * @return the previous ranges for this document.\n-     */\n-    @Nonnull\n-    SortedMap<Revision, Range> getPreviousRanges() {\n-        @SuppressWarnings(\"unchecked\")\n-        SortedMap<Revision, Range> previous = (SortedMap<Revision, Range>) get(PREVIOUS);\n-        if (previous == null) {\n-            previous = EMPTY_RANGE_MAP;\n         }\n         return previous;\n     }\n",
    "project": "jackrabbit-oak"
}