{
    "bug_id": 60,
    "classification": {
        "singleLine": false
    },
    "commit": "716e1237",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest"
    ],
    "files": 2,
    "jira_id": "1877",
    "linesAdd": 149,
    "linesRem": 141,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 9,
    "nb_test": 1807,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex d52c43090d..74755fe40e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -21,11 +21,9 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;\n import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_DONE;\n-import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_RUNNING;\n import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n-import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n import java.util.Calendar;\n import java.util.HashSet;\n@@ -36,18 +34,15 @@\n \n import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n-import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;\n import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;\n-import org.apache.jackrabbit.oak.plugins.value.Conversions;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorDiff;\n import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n-import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;\n@@ -75,8 +70,9 @@\n             \"Async\", 1, \"Concurrent update detected\");\n \n     /**\n-     * Timeout in minutes after which an async job would be considered as timed out. Another\n-     * node in cluster would wait for timeout before taking over a running job\n+     * Timeout in minutes after which an async job would be considered as\n+     * timed out. Another node in cluster would wait for timeout before\n+     * taking over a running job\n      */\n     private static final int ASYNC_TIMEOUT = 15;\n \n@@ -125,13 +121,55 @@ public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,\n      */\n     private class AsyncUpdateCallback implements IndexUpdateCallback {\n \n-        private boolean dirty = false;\n+        /** The base checkpoint */\n+        private final String checkpoint;\n+\n+        /** Expiration time of the last lease we committed */\n+        private long lease;\n+\n+        private long updates = 0;\n+\n+        public AsyncUpdateCallback(String checkpoint)\n+                throws CommitFailedException {\n+            long now = System.currentTimeMillis();\n+            this.checkpoint = checkpoint;\n+            this.lease = now + 2 * ASYNC_TIMEOUT;\n+\n+            String leaseName = name + \"-lease\";\n+            NodeState root = store.getRoot();\n+            long beforeLease = root.getChildNode(ASYNC).getLong(leaseName);\n+            if (beforeLease > now) {\n+                throw CONCURRENT_UPDATE;\n+            }\n+\n+            NodeBuilder builder = root.builder();\n+            builder.child(ASYNC).setProperty(leaseName, lease);\n+            mergeWithConcurrencyCheck(builder, checkpoint, beforeLease);\n+        }\n+\n+        boolean isDirty() {\n+            return updates > 0;\n+        }\n+\n+        void close() throws CommitFailedException {\n+            NodeBuilder builder = store.getRoot().builder();\n+            NodeBuilder async = builder.child(ASYNC);\n+            async.removeProperty(name + \"-lease\");\n+            mergeWithConcurrencyCheck(builder, async.getString(name), lease);\n+        }\n \n         @Override\n         public void indexUpdate() throws CommitFailedException {\n-            if (!dirty) {\n-                dirty = true;\n-                preAsyncRun(store, name);\n+            updates++;\n+            if (updates % 100 == 0) {\n+                long now = System.currentTimeMillis();\n+                if (now + ASYNC_TIMEOUT > lease) {\n+                    long newLease = now + 2 * ASYNC_TIMEOUT;\n+                    NodeBuilder builder = store.getRoot().builder();\n+                    builder.child(ASYNC).setProperty(name + \"-lease\", newLease);\n+                    mergeWithConcurrencyCheck(builder, checkpoint, lease);\n+                    lease = newLease;\n+                }\n             }\n         }\n \n@@ -141,20 +179,26 @@ public void indexUpdate() throws CommitFailedException {\n     public synchronized void run() {\n         log.debug(\"Running background index task {}\", name);\n \n-        if (isAlreadyRunning(store, name)) {\n-            log.debug(\"The {} indexer is already running; skipping this update\", name);\n+        NodeState root = store.getRoot();\n+\n+        // check for concurrent updates\n+        NodeState async = root.getChildNode(ASYNC);\n+        if (async.getLong(name + \"-lease\") > System.currentTimeMillis()) {\n+            log.debug(\"Another copy of the {} index update is already running;\"\n+                    + \" skipping this update\", name);\n             return;\n         }\n \n+        // find the last indexed state, and check if there are recent changes\n         NodeState before;\n-        NodeState root = store.getRoot();\n-        String refCheckpoint = root.getChildNode(ASYNC).getString(name);\n-        if (refCheckpoint != null) {\n-            NodeState state = store.retrieve(refCheckpoint);\n+        String beforeCheckpoint = async.getString(name);\n+        if (beforeCheckpoint != null) {\n+            NodeState state = store.retrieve(beforeCheckpoint);\n             if (state == null) {\n                 log.warn(\"Failed to retrieve previously indexed checkpoint {};\"\n-                        + \" rerunning the initial {} index update\",\n-                        refCheckpoint, name);\n+                        + \" re-running the initial {} index update\",\n+                        beforeCheckpoint, name);\n+                beforeCheckpoint = null;\n                 before = MISSING_NODE;\n             } else if (noVisibleChanges(state, root)) {\n                 log.debug(\"No changes since last checkpoint;\"\n@@ -168,43 +212,84 @@ public synchronized void run() {\n             before = MISSING_NODE;\n         }\n \n-        String checkpoint = store.checkpoint(lifetime);\n-        NodeState after = store.retrieve(checkpoint);\n+        // there are some recent changes, so let's create a new checkpoint\n+        String afterCheckpoint = store.checkpoint(lifetime);\n+        NodeState after = store.retrieve(afterCheckpoint);\n         if (after == null) {\n             log.warn(\"Unable to retrieve newly created checkpoint {},\"\n-                    + \" skipping the {} index update\", checkpoint, name);\n+                    + \" skipping the {} index update\", afterCheckpoint, name);\n             return;\n         }\n \n-        NodeBuilder builder = store.getRoot().builder();\n-        NodeBuilder async = builder.child(ASYNC);\n-\n-        AsyncUpdateCallback callback = new AsyncUpdateCallback();\n-        preAsyncRunStatsStats(indexStats);\n-        IndexUpdate indexUpdate = new IndexUpdate(\n-                provider, name, after, builder, callback);\n-\n-        CommitFailedException exception = EditorDiff.process(\n-                indexUpdate, before, after);\n-        if (exception == null) {\n-            if (callback.dirty) {\n-                async.setProperty(name, checkpoint);\n+        String checkpointToRelease = afterCheckpoint;\n         try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+            updateIndex(before, beforeCheckpoint, after, afterCheckpoint);\n+\n+            // the update succeeded, i.e. it no longer fails\n+            if (failing) {\n+                log.info(\"Index update {} no longer fails\", name);\n+                failing = false;\n+            }\n+\n+            // the update succeeded, so we can release the earlier checkpoint\n+            // otherwise the new checkpoint associated with the failed update\n+            // will get released in the finally block\n+            checkpointToRelease = beforeCheckpoint;\n+\n         } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n+            if (e == CONCURRENT_UPDATE) {\n+                log.debug(\"Concurrent update detected in the {} index update\", name);\n+            } else if (failing) {\n+                log.debug(\"The {} index update is still failing\", name, e);\n+            } else {\n+                log.warn(\"The {} index update failed\", name, e);\n+                failing = true;\n             }\n+\n+        } finally {\n+            if (checkpointToRelease != null) { // null during initial indexing\n+                store.release(checkpointToRelease);\n+            }\n+        }\n+    }\n+\n+    private void updateIndex(\n+            NodeState before, String beforeCheckpoint,\n+            NodeState after, String afterCheckpoint)\n+            throws CommitFailedException {\n+        // start collecting runtime statistics\n+        preAsyncRunStatsStats(indexStats);\n+\n+        // create an update callback for tracking index updates\n+        // and maintaining the update lease\n+        AsyncUpdateCallback callback =\n+                new AsyncUpdateCallback(beforeCheckpoint);\n+        try {\n+            NodeBuilder builder = store.getRoot().builder();\n+\n+            IndexUpdate indexUpdate =\n+                    new IndexUpdate(provider, name, after, builder, callback);\n+            CommitFailedException exception =\n+                    EditorDiff.process(indexUpdate, before, after);\n+            if (exception != null) {\n+                throw exception;\n             }\n+\n+            if (callback.isDirty() || before == MISSING_NODE) {\n+                builder.child(ASYNC).setProperty(name, afterCheckpoint);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n+\n                 if (switchOnSync) {\n                     reindexedDefinitions.addAll(\n                             indexUpdate.getReindexedDefinitions());\n+                } else {\n+                    postAsyncRunStatsStatus(indexStats);\n                 }\n             } else if (switchOnSync) {\n-                log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \"\n-                        + reindexedDefinitions);\n-                async.setProperty(name, checkpoint);\n+                log.debug(\"No changes detected after diff; will try to\"\n+                        + \" switch to synchronous updates on {}\",\n+                        reindexedDefinitions);\n \n                 // no changes after diff, switch to sync on the async defs\n                 for (String path : reindexedDefinitions) {\n@@ -217,125 +302,48 @@ public synchronized void run() {\n                     }\n                 }\n \n-                try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n                 reindexedDefinitions.clear();\n-                } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n             }\n+        } finally {\n+            callback.close();\n         }\n-            }\n-        }\n-        postAsyncRunStatsStatus(indexStats);\n \n-        // checkpoints cleanup\n-        if (exception != null || (exception == null && !callback.dirty)) {\n-            log.debug(\"The {} index update failed; releasing the related checkpoint {}\",\n-                    name, checkpoint);\n-            store.release(checkpoint);\n-        } else {\n-            if (refCheckpoint != null) {\n-                log.debug(\n-                        \"The {} index update succeeded; releasing the previous checkpoint {}\",\n-                        name, refCheckpoint);\n-                store.release(refCheckpoint);\n-            }\n-        }\n-\n-        if (exception != null) {\n-            if (!failing) {\n-                log.warn(\"Index update {} failed\", name, exception);\n-            }\n-            failing = true;\n-        } else {\n-            if (failing) {\n-                log.info(\"Index update {} no longer fails\", name);\n-            }\n-            failing = false;\n-        }\n+        postAsyncRunStatsStatus(indexStats);\n     }\n \n-    private static CommitHook newCommitHook(\n-            final String name, final String checkpoint) {\n-        return new CompositeHook(\n-                new ConflictHook(new AnnotatingConflictHandler()),\n-                new EditorHook(new ConflictValidatorProvider()),\n-                new CommitHook() {\n+    private void mergeWithConcurrencyCheck(\n+            NodeBuilder builder, final String checkpoint, final long lease)\n+            throws CommitFailedException {\n+        CommitHook concurrentUpdateCheck = new CommitHook() {\n             @Override @Nonnull\n             public NodeState processCommit(\n                     NodeState before, NodeState after, CommitInfo info)\n                     throws CommitFailedException {\n                 // check for concurrent updates by this async task\n-                String checkpointAfterRebase =\n-                        before.getChildNode(ASYNC).getString(name);\n-                if (Objects.equal(checkpoint, checkpointAfterRebase)) {\n-                    return postAsyncRunNodeStatus(after.builder(), name)\n-                            .getNodeState();\n+                NodeState async = before.getChildNode(ASYNC);\n+                if (Objects.equal(checkpoint, async.getString(name))\n+                        && lease == async.getLong(name + \"-lease\")) {\n+                    return after;\n                 } else {\n+                    new Exception(checkpoint + \" - \" + async.getString(name)\n+                            + \" / \" + lease + \" - \" + async.getLong(name + \"-lease\")).printStackTrace();\n                     throw CONCURRENT_UPDATE;\n                 }\n             }\n-        });\n-    }\n-\n-    private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\n-        NodeBuilder builder = store.getRoot().builder();\n-        preAsyncRunNodeStatus(builder, name);\n-        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n-    }\n-\n-    private static boolean isAlreadyRunning(NodeStore store, String name) {\n-        NodeState indexState = store.getRoot().getChildNode(INDEX_DEFINITIONS_NAME);\n-\n-        //Probably the first run\n-        if (!indexState.exists()) {\n-            return false;\n-        }\n-\n-        //Check if already running or timed out\n-        if (STATUS_RUNNING.equals(indexState.getString(name + \"-status\"))) {\n-            PropertyState startTime = indexState.getProperty(name + \"-start\");\n-            Calendar start = Conversions.convert(startTime.getValue(Type.DATE)).toCalendar();\n-            Calendar now = Calendar.getInstance();\n-            long delta = now.getTimeInMillis() - start.getTimeInMillis();\n-\n-            //Check if the job has timed out and we need to take over\n-            if (TimeUnit.MILLISECONDS.toMinutes(delta) > ASYNC_TIMEOUT) {\n-                log.info(\"Async job found which stated on {} has timed out in {} minutes. \" +\n-                        \"This node would take over the job.\",\n-                        startTime.getValue(Type.DATE), ASYNC_TIMEOUT);\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_RUNNING)\n-                .setProperty(name + \"-start\", now, Type.DATE)\n-                .removeProperty(name + \"-done\");\n+        };\n+        CompositeHook hooks = new CompositeHook(\n+                new ConflictHook(new AnnotatingConflictHandler()),\n+                new EditorHook(new ConflictValidatorProvider()),\n+                concurrentUpdateCheck);\n+        store.merge(builder, hooks, CommitInfo.EMPTY);\n     }\n \n     private static void preAsyncRunStatsStats(AsyncIndexStats stats) {\n         stats.start(now());\n     }\n \n-    private static NodeBuilder postAsyncRunNodeStatus(\n-            NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_DONE)\n-                .setProperty(name + \"-done\", now, Type.DATE)\n-                .removeProperty(name + \"-start\");\n-        return builder;\n-    }\n-\n      private static void postAsyncRunStatsStatus(AsyncIndexStats stats) {\n         stats.done(now());\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 75f0f3195c..914f23fda6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -102,7 +102,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n         this.provider = parent.provider;\n         this.async = parent.async;\n         this.root = parent.root;\n-        this.builder = parent.builder.child(checkNotNull(name));\n+        this.builder = parent.builder.getChildNode(checkNotNull(name));\n         this.updateCallback = parent.updateCallback;\n     }\n \n",
    "project": "jackrabbit-oak"
}