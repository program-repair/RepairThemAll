{
    "bug_id": 61,
    "classification": {
        "singleLine": false
    },
    "commit": "3efb5cbf",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
    ],
    "files": 3,
    "jira_id": "1662",
    "linesAdd": 36,
    "linesRem": 19,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 8,
    "nb_test": 1776,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 2e32b74237..5d7b137e2a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -20,6 +20,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -53,7 +54,7 @@\n     private final Revision revision;\n     private HashMap<String, UpdateOp> operations = new LinkedHashMap<String, UpdateOp>();\n     private JsopWriter diff = new JsopStream();\n-    private List<Revision> collisions = new ArrayList<Revision>();\n+    private Set<Revision> collisions = new LinkedHashSet<Revision>();\n \n     /**\n      * List of all node paths which have been modified in this commit. In addition to the nodes\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 770cc9cc1d..8b4eb792fa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1210,7 +1210,7 @@ public DocumentNodeState getRoot() {\n     @Override\n     public NodeState merge(@Nonnull NodeBuilder builder,\n                            @Nonnull CommitHook commitHook,\n-                           @Nullable CommitInfo info)\n+                           @Nonnull CommitInfo info)\n             throws CommitFailedException {\n         return asDocumentRootBuilder(builder).merge(commitHook, info);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 35a230685d..e685b36482 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -581,29 +581,45 @@ public String getCommitRootPath(Revision revision) {\n      * @return the revision, or null if deleted\n      */\n     @CheckForNull\n-    public Revision getNewestRevision(RevisionContext context,\n-                                      Revision changeRev,\n-                                      CollisionHandler handler) {\n-        // no need to look at all commits. the primary document\n-        // always contains at least one commit, including all\n-        // branch commits which are not yet merged\n+    public Revision getNewestRevision(final RevisionContext context,\n+                                      final Revision changeRev,\n+                                      final CollisionHandler handler) {\n+        final Map<Revision, String> validRevisions = Maps.newHashMap();\n+        Predicate<Revision> predicate = new Predicate<Revision>() {\n+            @Override\n+            public boolean apply(Revision input) {\n+                if (input.equals(changeRev)) {\n+                    return false;\n+                }\n+                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n+                    return true;\n+                }\n+                handler.concurrentModification(input);\n+                return false;\n+            }\n+        };\n+\n+        Revision newestRev = null;\n+        // check local commits first\n         SortedMap<Revision, String> revisions = getLocalRevisions();\n         SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n-        Revision newestRev = null;\n-        for (Revision r : Iterables.mergeSorted(\n+        Iterator<Revision> it = filter(Iterables.mergeSorted(\n                 Arrays.asList(revisions.keySet(), commitRoots.keySet()),\n-                revisions.comparator())) {\n-            if (!r.equals(changeRev)) {\n-                if (isValidRevision(context, r, null, changeRev, new HashMap<Revision, String>())) {\n-                    newestRev = r;\n-                    // found newest revision, no need to check more revisions\n-                    // revisions are sorted newest first\n-                    break;\n+                revisions.comparator()), predicate).iterator();\n+        if (it.hasNext()) {\n+            newestRev = it.next();\n         } else {\n-                    handler.concurrentModification(r);\n-                }\n+            // check full history (only needed in rare cases)\n+            it = filter(Iterables.mergeSorted(\n+                    Arrays.asList(\n+                            getValueMap(REVISIONS).keySet(),\n+                            getValueMap(COMMIT_ROOT).keySet()),\n+                    revisions.comparator()), predicate).iterator();\n+            if (it.hasNext()) {\n+                newestRev = it.next();\n             }\n         }\n+\n         if (newestRev == null) {\n             return null;\n         }\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}