{
    "bug_id": 256,
    "classification": {
        "singleLine": false
    },
    "commit": "9772f5b2",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.document.ClusterNodeRestartTest"
    ],
    "files": 2,
    "jira_id": "3549",
    "linesAdd": 79,
    "linesRem": 41,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 1,
    "nb_test": 2968,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 49496ee3f0..9e3eac27f4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -127,7 +127,7 @@ public void dispose() {\n     }\n \n     void backgroundRead() {\n-        nodeStore.backgroundRead(true);\n+        nodeStore.backgroundRead();\n     }\n \n     void backgroundWrite() {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 061a3645fb..347d694fa2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n@@ -487,27 +488,29 @@ public int getMemory() {\n             setHeadRevision(commit.getRevision());\n             // make sure _lastRev is written back to store\n             backgroundWrite();\n-        } else {\n-            // initialize branchCommits\n-            branches.init(store, this);\n-            // initial reading of the revisions of other cluster nodes\n-            backgroundRead(false);\n-            if (headRevision == null) {\n-                // no revision read from other cluster nodes\n-                setHeadRevision(newRevision());\n+            rootDoc = store.find(NODES, Utils.getIdFromPath(\"/\"));\n+            // at this point the root document must exist\n+            if (rootDoc == null) {\n+                throw new IllegalStateException(\"Root document does not exist\");\n             }\n+        } else {\n+            checkLastRevRecovery();\n+            initializeHeadRevision(rootDoc);\n             // check if _lastRev for our clusterId exists\n             if (!rootDoc.getLastRev().containsKey(clusterId)) {\n                 unsavedLastRevisions.put(\"/\", headRevision);\n                 backgroundWrite();\n             }\n         }\n-        checkLastRevRecovery();\n+\n         // Renew the lease because it may have been stale\n         renewClusterIdLease();\n \n         getRevisionComparator().add(headRevision, Revision.newRevision(0));\n \n+        // initialize branchCommits\n+        branches.init(store, this);\n+\n         dispatcher = new ChangeDispatcher(getRoot());\n         commitQueue = new CommitQueue(this);\n         String threadNamePostfix = \"(\" + clusterId + \")\";\n@@ -1693,7 +1696,7 @@ private void internalRunBackgroundReadOperations() {\n         synchronized (backgroundReadMonitor) {\n             long start = clock.getTime();\n             // pull in changes from other cluster nodes\n-            BackgroundReadStats readStats = backgroundRead(true);\n+            BackgroundReadStats readStats = backgroundRead();\n             long readTime = clock.getTime() - start;\n             String msg = \"Background read operations stats (read:{} {})\";\n             if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n@@ -1762,11 +1765,8 @@ boolean updateClusterState() {\n \n     /**\n      * Perform a background read and make external changes visible.\n-     *\n-     * @param dispatchChange whether to dispatch external changes\n-     *                       to {@link #dispatcher}.\n      */\n-    BackgroundReadStats backgroundRead(boolean dispatchChange) {\n+    BackgroundReadStats backgroundRead() {\n         BackgroundReadStats stats = new BackgroundReadStats();\n         long time = clock.getTime();\n         String id = Utils.getIdFromPath(\"/\");\n@@ -1774,30 +1774,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n         if (doc == null) {\n             return stats;\n         }\n-        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n-        try {\n-            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n-            long localTime = clock.getTime();\n-            if (localTime < externalTime) {\n-                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n-                                \"while most recent external time is '{}'. \" +\n-                                \"Current _lastRev entries: {}\",\n-                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n-                double delay = ((double) externalTime - localTime) / 1000d;\n-                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n-                        \"Please check system time on cluster nodes.\", delay);\n-                LOG.warn(msg);\n-                clock.waitUntil(externalTime + 1);\n-            } else if (localTime == externalTime) {\n-                // make sure local time is past external time\n-                // but only log at debug\n-                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n-                        \"time is more recent than external reported time.\");\n-                clock.waitUntil(externalTime + 1);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Background read interrupted\", e);\n-        }\n+        alignWithExternalRevisions(doc);\n \n         Revision.RevisionComparator revisionComparator = getRevisionComparator();\n         // the (old) head occurred first\n@@ -1807,6 +1784,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n \n         StringSort externalSort = JournalEntry.newSorter();\n \n+        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n         try {\n             Map<Revision, Revision> externalChanges = Maps.newHashMap();\n             for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n@@ -1899,7 +1877,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     Revision oldHead = headRevision;\n                     // the new head revision is after other revisions\n                     setHeadRevision(newRevision());\n-                    if (dispatchChange) {\n                     commitQueue.headRevisionChanged();\n                     time = clock.getTime();\n                     if (externalSort != null) {\n@@ -1915,7 +1892,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     time = clock.getTime();\n \n                     dispatcher.contentChanged(getRoot().fromExternalChange(), null);\n-                    }\n                 } finally {\n                     backgroundOperationLock.writeLock().unlock();\n                 }\n@@ -2054,6 +2030,68 @@ public void acquiring(Revision mostRecent) {\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Performs an initial read of the _lastRevs on the root document,\n+     * initializes the {@link #revisionComparator} and sets the head revision.\n+     *\n+     * @param rootDoc the current root document.\n+     */\n+    private void initializeHeadRevision(NodeDocument rootDoc) {\n+        checkState(headRevision == null);\n+\n+        alignWithExternalRevisions(rootDoc);\n+        Map<Integer, Revision> lastRevMap = rootDoc.getLastRev();\n+        Revision seenAt = Revision.newRevision(0);\n+        long purgeMillis = revisionPurgeMillis();\n+        for (Map.Entry<Integer, Revision> entry : lastRevMap.entrySet()) {\n+            Revision r = entry.getValue();\n+            if (r.getTimestamp() > purgeMillis) {\n+                revisionComparator.add(r, seenAt);\n+            }\n+            if (entry.getKey() == clusterId) {\n+                continue;\n+            }\n+            lastKnownRevision.put(entry.getKey(), entry.getValue());\n+        }\n+        revisionComparator.purge(purgeMillis);\n+        setHeadRevision(newRevision());\n+    }\n+\n+    /**\n+     * Makes sure the current time is after the most recent external revision\n+     * timestamp in the _lastRev map of the given root document. If necessary\n+     * the current thread waits until {@link #clock} is after the external\n+     * revision timestamp.\n+     *\n+     * @param rootDoc the root document.\n+     */\n+    private void alignWithExternalRevisions(@Nonnull NodeDocument rootDoc) {\n+        Map<Integer, Revision> lastRevMap = checkNotNull(rootDoc).getLastRev();\n+        try {\n+            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n+            long localTime = clock.getTime();\n+            if (localTime < externalTime) {\n+                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n+                                \"while most recent external time is '{}'. \" +\n+                                \"Current _lastRev entries: {}\",\n+                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n+                double delay = ((double) externalTime - localTime) / 1000d;\n+                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n+                        \"Please check system time on cluster nodes.\", delay);\n+                LOG.warn(msg);\n+                clock.waitUntil(externalTime + 1);\n+            } else if (localTime == externalTime) {\n+                // make sure local time is past external time\n+                // but only log at debug\n+                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n+                        \"time is more recent than external reported time.\");\n+                clock.waitUntil(externalTime + 1);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Background read interrupted\", e);\n+        }\n+    }\n+\n     @Nonnull\n     private Commit newTrunkCommit(@Nonnull Revision base) {\n         checkArgument(!checkNotNull(base).isBranch(),\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}