{
    "bug_id": 111,
    "classification": {
        "singleLine": false
    },
    "commit": "557eec4f",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.index.property.MultiPropertyOrTest"
    ],
    "files": 4,
    "jira_id": "4038",
    "linesAdd": 1,
    "linesRem": 79,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 1,
    "nb_test": 2801,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 40eca042f3..3ec211f98b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -192,7 +192,7 @@ public double getCost(Filter filter, NodeState root) {\n             // not an appropriate index for native search\n             return Double.POSITIVE_INFINITY;\n         }\n-        if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n+        if (filter.getPropertyRestrictions().isEmpty()) {\n             // not an appropriate index for no property restrictions & selector constraints\n             return Double.POSITIVE_INFINITY;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex b1123a0043..d15c273836 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -35,14 +35,6 @@\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.IndexStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.UniqueEntryStoreStrategy;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.ComparisonImpl;\n-import org.apache.jackrabbit.oak.query.ast.ConstraintImpl;\n-import org.apache.jackrabbit.oak.query.ast.DynamicOperandImpl;\n-import org.apache.jackrabbit.oak.query.ast.InImpl;\n-import org.apache.jackrabbit.oak.query.ast.Operator;\n-import org.apache.jackrabbit.oak.query.ast.OrImpl;\n-import org.apache.jackrabbit.oak.query.ast.PropertyValueImpl;\n-import org.apache.jackrabbit.oak.query.ast.StaticOperandImpl;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n import org.apache.jackrabbit.oak.spi.query.Cursors;\n import org.apache.jackrabbit.oak.spi.query.Filter;\n@@ -72,8 +64,6 @@\n     private static final IndexStoreStrategy UNIQUE =\n             new UniqueEntryStoreStrategy();\n \n-    private final NodeState root;\n-\n     private final NodeState definition;\n \n     private final String name;\n@@ -98,7 +88,6 @@\n \n     PropertyIndexPlan(String name, NodeState root, NodeState definition, Filter filter) {\n         this.name = name;\n-        this.root = root;\n         this.definition = definition;\n         this.properties = newHashSet(definition.getNames(PROPERTY_NAMES));\n         pathFilter = PathFilter.from(definition.builder());\n@@ -162,24 +151,6 @@\n                     }\n                 }\n             }\n-\n-            // OAK-1965: let's see if we can find a (x='...' OR y='...')\n-            // constraint where both x and y are covered by this index\n-            // TODO: avoid repeated scans through the constraints\n-            for (ConstraintImpl constraint\n-                    : filter.getSelector().getSelectorConstraints()) {\n-                if (constraint instanceof OrImpl) {\n-                    Set<String> values = findMultiProperty((OrImpl) constraint);\n-                    if (values != null) {\n-                        double cost = strategy.count(filter, root, definition, values, MAX_COST);\n-                        if (cost < bestCost) {\n-                            bestDepth = 1;\n-                            bestValues = values;\n-                            bestCost = cost;\n-                        }\n-                    }\n-                }\n-            }\n         }\n \n         this.depth = bestDepth;\n@@ -187,46 +158,6 @@\n         this.cost = COST_OVERHEAD + bestCost;\n     }\n \n-    private Set<String> findMultiProperty(OrImpl or) {\n-        Set<String> values = newLinkedHashSet();\n-        for (ConstraintImpl constraint : or.getConstraints()) {\n-            if (constraint instanceof ComparisonImpl) {\n-                ComparisonImpl comparison = (ComparisonImpl) constraint;\n-                if (isIndexed(comparison.getOperand1())\n-                        && comparison.getOperator() == Operator.EQUAL) {\n-                    values.addAll(encode(comparison.getOperand2().currentValue()));\n-                } else {\n-                    return null;\n-                }\n-            } else if (constraint instanceof InImpl) {\n-                InImpl in = (InImpl) constraint;\n-                if (isIndexed(in.getOperand1())) {\n-                    for (StaticOperandImpl operand : in.getOperand2()) {\n-                        values.addAll(encode(operand.currentValue()));\n-                    }\n-                } else {\n-                    return null;\n-                }\n-            } else {\n-                return null;\n-            }\n-        }\n-        return values;\n-    }\n-\n-    /**\n-     * Checks whether the given dynamic operand is a property\n-     * covered by this index.\n-     */\n-    private boolean isIndexed(DynamicOperandImpl operand) {\n-        if (operand instanceof PropertyValueImpl) {\n-            PropertyValueImpl property = (PropertyValueImpl) operand;\n-            return properties.contains(property.getPropertyName());\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6908950dcf..0f851b14de 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -218,7 +218,6 @@ public boolean isAlwaysFalse() {\n         return alwaysFalse;\n     }\n \n-    @Override\n     public SelectorImpl getSelector() {\n         return selector;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\nindex f2e55fd1e3..9aabf1a77b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n@@ -28,7 +28,6 @@\n \n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.SelectorImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n \n /**\n@@ -44,13 +43,6 @@\n  */\n public interface Filter {\n \n-    /**\n-     * Get the selector associated with this filter.\n-     *\n-     * @return selector\n-     */\n-    SelectorImpl getSelector();\n-\n     /**\n      * Get the list of property restrictions, if any. Each property may contain\n      * multiple restrictions, for example x=1 and x=2. For this case, only\n",
    "project": "jackrabbit-oak",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}