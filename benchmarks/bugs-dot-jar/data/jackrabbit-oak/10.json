{
    "bug_id": 10,
    "classification": {
        "singleLine": false
    },
    "commit": "3e83a4c1",
    "failing_tests": [
        "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
    ],
    "files": 4,
    "jira_id": "1822",
    "linesAdd": 84,
    "linesRem": 28,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 9,
    "nb_test": 1802,
    "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex e0eb8656b6..e63e2d8abd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1205,7 +1205,7 @@ public static void setChildrenFlag(@Nonnull UpdateOp op,\n \n     public static void setModified(@Nonnull UpdateOp op,\n                                    @Nonnull Revision revision) {\n-        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n+        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n     }\n \n     public static void setRevision(@Nonnull UpdateOp op,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f00df7a79d..b957c37b22 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -131,9 +131,7 @@ public boolean hasChanges() {\n      * @param value the value\n      */\n     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET_MAP_ENTRY;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -145,8 +143,7 @@ void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String va\n      * @param revision the revision\n      */\n     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.REMOVE_MAP_ENTRY;\n+        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -157,9 +154,23 @@ public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision)\n      * @param value the value\n      */\n     void set(String property, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET, value);\n+        changes.put(new Key(property, null), op);\n+    }\n+\n+    /**\n+     * Set the property to the given value if the new value is higher than the\n+     * existing value. The property is also set to the given value if the\n+     * property does not yet exist.\n+     * <p>\n+     * The result of a max operation with different types of values is\n+     * undefined.\n+     *\n+     * @param property the name of the property to set.\n+     * @param value the new value for the property.\n+     */\n+    <T> void max(String property, Comparable<T> value) {\n+        Operation op = new Operation(Operation.Type.MAX, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -187,9 +198,7 @@ void containsMapEntry(@Nonnull String property,\n         if (isNew) {\n             throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\n         }\n-        Operation op = new Operation();\n-        op.type = Operation.Type.CONTAINS_MAP_ENTRY;\n-        op.value = exists;\n+        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -200,9 +209,7 @@ void containsMapEntry(@Nonnull String property,\n      * @param value the increment\n      */\n     public void increment(@Nonnull String property, long value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.INCREMENT;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.INCREMENT, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -238,6 +245,14 @@ public String toString() {\n              */\n             SET,\n \n+            /**\n+             * Set the value if the new value is higher than the existing value.\n+             * The new value is also considered higher, when there is no\n+             * existing value.\n+             * The sub-key is not used.\n+             */\n+            MAX,\n+\n             /**\n              * Increment the Long value with the provided Long value.\n              * The sub-key is not used.\n@@ -267,12 +282,17 @@ public String toString() {\n         /**\n          * The operation type.\n          */\n-        public Type type;\n+        public final Type type;\n \n         /**\n          * The value, if any.\n          */\n-        public Object value;\n+        public final Object value;\n+\n+        Operation(Type type, Object value) {\n+            this.type = checkNotNull(type);\n+            this.value = value;\n+        }\n \n         @Override\n         public String toString() {\n@@ -283,18 +303,16 @@ public Operation getReverse() {\n             Operation reverse = null;\n             switch (type) {\n             case INCREMENT:\n-                reverse = new Operation();\n-                reverse.type = Type.INCREMENT;\n-                reverse.value = -(Long) value;\n+                reverse = new Operation(Type.INCREMENT, -(Long) value);\n                 break;\n             case SET:\n+            case MAX:\n             case REMOVE_MAP_ENTRY:\n             case CONTAINS_MAP_ENTRY:\n                 // nothing to do\n                 break;\n             case SET_MAP_ENTRY:\n-                reverse = new Operation();\n-                reverse.type = Type.REMOVE_MAP_ENTRY;\n+                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);\n                 break;\n             }\n             return reverse;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\nindex b8015ff100..240665d422 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n@@ -44,7 +44,9 @@\n      * @param comparator\n      *            the revision comparator.\n      */\n-    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n+    public static void applyChanges(@Nonnull Document doc,\n+                                    @Nonnull UpdateOp update,\n+                                    @Nonnull Comparator<Revision> comparator) {\n         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n             Key k = e.getKey();\n             Operation op = e.getValue();\n@@ -53,6 +55,15 @@ public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update,\n                     doc.put(k.toString(), op.value);\n                     break;\n                 }\n+                case MAX: {\n+                    Comparable newValue = (Comparable) op.value;\n+                    Object old = doc.get(k.toString());\n+                    //noinspection unchecked\n+                    if (old == null || newValue.compareTo(old) > 0) {\n+                        doc.put(k.toString(), op.value);\n+                    }\n+                    break;\n+                }\n                 case INCREMENT: {\n                     Object old = doc.get(k.toString());\n                     Long x = (Long) op.value;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 0266e388a1..684f39f3f1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -29,6 +29,8 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.locks.Lock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n@@ -127,6 +129,7 @@\n     private String lastReadWriteMode;\n \n     public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n+        checkVersion(db);\n         nodes = db.getCollection(\n                 Collection.NODES.toString());\n         clusterNodes = db.getCollection(\n@@ -179,6 +182,24 @@ public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n                 builder.getDocumentCacheSize());\n     }\n \n+    private static void checkVersion(DB db) {\n+        String version = db.command(\"buildInfo\").getString(\"version\");\n+        Matcher m = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\..*\").matcher(version);\n+        if (!m.matches()) {\n+            throw new IllegalArgumentException(\"Malformed MongoDB version: \" + version);\n+        }\n+        int major = Integer.parseInt(m.group(1));\n+        int minor = Integer.parseInt(m.group(2));\n+        if (major > 2) {\n+            return;\n+        }\n+        if (minor < 6) {\n+            String msg = \"MongoDB version 2.6.0 or higher required. \" +\n+                    \"Currently connected to a MongoDB with version: \" + version;\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n     private Cache<CacheValue, NodeDocument> createOffHeapCache(\n             DocumentMK.Builder builder) {\n         ForwardingListener<CacheValue, NodeDocument> listener = ForwardingListener.newInstance();\n@@ -570,6 +591,7 @@ public NodeDocument call() throws Exception {\n                 Operation op = entry.getValue();\n                 switch (op.type) {\n                     case SET:\n+                    case MAX:\n                     case INCREMENT: {\n                         inserts[i].put(k.toString(), op.value);\n                         break;\n@@ -965,6 +987,7 @@ private static QueryBuilder createQueryForUpdate(UpdateOp updateOp,\n     @Nonnull\n     private static DBObject createUpdate(UpdateOp updateOp) {\n         BasicDBObject setUpdates = new BasicDBObject();\n+        BasicDBObject maxUpdates = new BasicDBObject();\n         BasicDBObject incUpdates = new BasicDBObject();\n         BasicDBObject unsetUpdates = new BasicDBObject();\n \n@@ -980,16 +1003,17 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n             }\n             Operation op = entry.getValue();\n             switch (op.type) {\n-                case SET: {\n+                case SET:\n+                case SET_MAP_ENTRY: {\n                     setUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case INCREMENT: {\n-                    incUpdates.append(k.toString(), op.value);\n+                case MAX: {\n+                    maxUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case SET_MAP_ENTRY: {\n-                    setUpdates.append(k.toString(), op.value);\n+                case INCREMENT: {\n+                    incUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n                 case REMOVE_MAP_ENTRY: {\n@@ -1003,6 +1027,9 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n         if (!setUpdates.isEmpty()) {\n             update.append(\"$set\", setUpdates);\n         }\n+        if (!maxUpdates.isEmpty()) {\n+            update.append(\"$max\", maxUpdates);\n+        }\n         if (!incUpdates.isEmpty()) {\n             update.append(\"$inc\", incUpdates);\n         }\n",
    "project": "jackrabbit-oak"
}