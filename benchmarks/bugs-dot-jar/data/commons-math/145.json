{
    "bug_id": 145,
    "classification": {
        "singleLine": false
    },
    "commit": "ac597cc1",
    "failing_tests": [
        "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest"
    ],
    "files": 1,
    "jira_id": "855",
    "linesAdd": 29,
    "linesRem": 11,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 4,
    "nb_test": 4084,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex cff5bfd33..25f2f5049 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -24,13 +24,19 @@\n import org.apache.commons.math3.optimization.GoalType;\n \n /**\n- * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * For a function defined on some interval {@code (lo, hi)}, this class\n+ * finds an approximation {@code x} to the point at which the function\n+ * attains its minimum.\n+ * It implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n- * univariate functions. This implementation is an adaptation partly\n- * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n- * If the function is defined on some interval {@code (lo, hi)}, then\n- * this method finds an approximation {@code x} to the point at which\n- * the function attains its minimum.\n+ * univariate functions.\n+ * <br/>\n+ * This code is an adaptation, partly based on the Python code from SciPy\n+ * (module \"optimize.py\" v0.5); the original algorithm is also modified\n+ * <ul>\n+ *  <li>to use an initial guess provided by the user,</li>\n+ *  <li>to ensure that the best point encountered is the one returned.</li>\n+ * </ul>\n  *\n  * @version $Id$\n  * @since 2.0\n@@ -141,6 +147,8 @@ protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair previous = null;\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+        // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -224,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                best = best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return best;\n                     }\n                 }\n \n@@ -264,7 +277,11 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n             }\n             ++iter;\n         }\n@@ -278,7 +295,8 @@ protected UnivariatePointValuePair doOptimize() {\n      * @param isMinim {@code true} if the selected point must be the one with\n      * the lowest value.\n      * @return the best point, or {@code null} if {@code a} and {@code b} are\n-     * both {@code null}.\n+     * both {@code null}. When {@code a} and {@code b} have the same function\n+     * value, {@code a} is returned.\n      */\n     private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                           UnivariatePointValuePair b,\n@@ -291,9 +309,9 @@ private UnivariatePointValuePair best(UnivariatePointValuePair a,\n         }\n \n         if (isMinim) {\n-            return a.getValue() < b.getValue() ? a : b;\n+            return a.getValue() <= b.getValue() ? a : b;\n         } else {\n-            return a.getValue() > b.getValue() ? a : b;\n+            return a.getValue() >= b.getValue() ? a : b;\n         }\n     }\n }\n",
    "project": "commons-math"
}