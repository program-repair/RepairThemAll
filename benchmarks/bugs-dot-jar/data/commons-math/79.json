{
    "bug_id": 79,
    "classification": {
        "singleLine": false
    },
    "commit": "133cbc2d",
    "failing_tests": [
        "org.apache.commons.math.optimization.linear.SimplexSolverTest"
    ],
    "files": 2,
    "jira_id": "434",
    "linesAdd": 84,
    "linesRem": 23,
    "nb_error": 0,
    "nb_failure": 3,
    "nb_skipped": 1,
    "nb_test": 2377,
    "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 5c25548dd..b9afc0ad6 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -22,6 +22,7 @@\n \n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n \n@@ -32,25 +33,33 @@\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n     \n-    /** Default amount of error to accept in floating point comparisons. */\n+    /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n      \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n+    /** Amount of error to accept in floating point comparisons (as ulps). */\n+    protected final int maxUlps;\n+\n     /**\n      * Build a simplex solver with default settings.\n      */\n     public SimplexSolver() {\n-        this(DEFAULT_EPSILON);\n+        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n     }\n \n     /**\n      * Build a simplex solver with a specified accepted amount of error\n-     * @param epsilon the amount of error to accept in floating point comparisons\n+     * @param epsilon the amount of error to accept for algorithm convergence\n+     * @param maxUlps amount of error to accept in floating point comparisons \n      */\n-    public SimplexSolver(final double epsilon) {\n+    public SimplexSolver(final double epsilon, final int maxUlps) {\n         this.epsilon = epsilon;\n+        this.maxUlps = maxUlps;\n     }\n \n     /**\n@@ -62,8 +71,9 @@ private Integer getPivotColumn(SimplexTableau tableau) {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, minValue, getEpsilon(entry)) < 0) {\n+                minValue = entry;\n                 minPos = i;\n             }\n         }\n@@ -83,11 +93,13 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            \n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 final double ratio = rhs / entry;\n-                if (MathUtils.equals(ratio, minRatio, epsilon)) {\n+                final int cmp = MathUtils.compareTo(ratio, minRatio, getEpsilon(ratio));\n+                if (cmp == 0) {\n                     minRatioPositions.add(i);\n-                } else if (ratio < minRatio) {\n+                } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n                     minRatioPositions.add(i);\n@@ -103,7 +115,8 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n           for (Integer row : minRatioPositions) {\n             for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n               int column = i + tableau.getArtificialVariableOffset();\n-              if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) &&\n+              final double entry = tableau.getEntry(row, column);\n+              if (MathUtils.equals(entry, 1d, getEpsilon(entry)) &&\n                   row.equals(tableau.getBasicRow(column))) {\n                 return row;\n               }\n@@ -162,7 +175,7 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n         }\n \n         // if W is not zero then we have no feasible solution\n-        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n             throw new NoFeasibleSolutionException();\n         }\n     }\n@@ -171,7 +184,8 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n     @Override\n     public RealPointValuePair doOptimize() throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n+            new SimplexTableau(function, linearConstraints, goal, nonNegative, \n+                               epsilon, maxUlps);\n \n         solvePhase1(tableau);\n         tableau.dropPhase1Objective();\n@@ -182,4 +196,12 @@ public RealPointValuePair doOptimize() throws OptimizationException {\n         return tableau.getSolution();\n     }\n \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 647d6bebd..0d1d91122 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -33,6 +33,7 @@\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n@@ -65,6 +66,9 @@\n     /** Column label for negative vars. */\n     private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1369660067587938365L;\n \n@@ -92,9 +96,12 @@\n     /** Number of artificial variables. */\n     private int numArtificialVariables;\n \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept when checking for optimality. */\n     private final double epsilon;\n \n+    /** Amount of error to accept in floating point comparisons. */\n+    private final int maxUlps;\n+\n     /**\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n@@ -102,16 +109,35 @@\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n-     * @param epsilon amount of error to accept in floating point comparisons\n+     * @param epsilon amount of error to accept when checking for optimality\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n+        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n+    }\n+    \n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @param epsilon amount of error to accept when checking for optimality\n+     * @param maxUlps amount of error to accept in floating point comparisons \n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative,\n+                   final double epsilon,\n+                   final int maxUlps) {\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n+        this.maxUlps                = maxUlps;\n         this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                       (restrictToNonNegative ? 0 : 1);\n         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n@@ -172,7 +198,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n-                getInvertedCoeffiecientSum(objectiveCoefficients));\n+                getInvertedCoefficientSum(objectiveCoefficients));\n         }\n \n         // initialize the constraint rows\n@@ -188,7 +214,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n             // x-\n             if (!restrictToNonNegative) {\n                 matrix.setEntry(row, getSlackVariableOffset() - 1,\n-                    getInvertedCoeffiecientSum(constraint.getCoefficients()));\n+                    getInvertedCoefficientSum(constraint.getCoefficients()));\n             }\n \n             // RHS\n@@ -269,7 +295,7 @@ private int getConstraintTypeCounts(final Relationship relationship) {\n      * @param coefficients coefficients to sum\n      * @return the -1 times the sum of all coefficients in the given array.\n      */\n-    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n         double sum = 0;\n         for (double coefficient : coefficients.getData()) {\n             sum -= coefficient;\n@@ -285,9 +311,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     protected Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = 0; i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            final double entry = getEntry(i, col);\n+            if (MathUtils.equals(entry, 1d, getEpsilon(entry)) && (row == null)) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+            } else if (!MathUtils.equals(entry, 0d, getEpsilon(entry))) {\n                 return null;\n             }\n         }\n@@ -308,7 +335,8 @@ protected void dropPhase1Objective() {\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n-          if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n@@ -353,7 +381,8 @@ private void copyArray(final double[] src, final double[] dest) {\n      */\n     boolean isOptimal() {\n         for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {\n                 return false;\n             }\n         }\n@@ -382,7 +411,7 @@ protected RealPointValuePair getSolution() {\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n-              coefficients[i] = 0;\n+              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n               coefficients[i] =\n@@ -545,6 +574,7 @@ public boolean equals(Object other) {\n                  (numSlackVariables      == rhs.numSlackVariables) &&\n                  (numArtificialVariables == rhs.numArtificialVariables) &&\n                  (epsilon                == rhs.epsilon) &&\n+                 (maxUlps                == rhs.maxUlps) &&\n                  f.equals(rhs.f) &&\n                  constraints.equals(rhs.constraints) &&\n                  tableau.equals(rhs.tableau);\n@@ -560,6 +590,7 @@ public int hashCode() {\n                numSlackVariables ^\n                numArtificialVariables ^\n                Double.valueOf(epsilon).hashCode() ^\n+               maxUlps ^\n                f.hashCode() ^\n                constraints.hashCode() ^\n                tableau.hashCode();\n@@ -586,4 +617,12 @@ private void readObject(ObjectInputStream ois)\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n     }\n     \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }    \n }\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}