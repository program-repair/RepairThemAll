{
    "bug_id": 130,
    "classification": {
        "singleLine": false
    },
    "commit": "2b852d79",
    "failing_tests": [
        "org.apache.commons.math3.stat.correlation.SpearmansRankCorrelationTest"
    ],
    "files": 1,
    "jira_id": "891",
    "linesAdd": 99,
    "linesRem": 16,
    "nb_error": 1,
    "nb_failure": 1,
    "nb_skipped": 4,
    "nb_test": 4921,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\nindex 2cd4151ab..14c48c67d 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n@@ -17,22 +17,28 @@\n \n package org.apache.commons.math3.stat.correlation;\n \n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.ranking.NaNStrategy;\n import org.apache.commons.math3.stat.ranking.NaturalRanking;\n import org.apache.commons.math3.stat.ranking.RankingAlgorithm;\n \n /**\n- * <p>Spearman's rank correlation. This implementation performs a rank\n+ * Spearman's rank correlation. This implementation performs a rank\n  * transformation on the input data and then computes {@link PearsonsCorrelation}\n- * on the ranked data.</p>\n- *\n- * <p>By default, ranks are computed using {@link NaturalRanking} with default\n+ * on the ranked data.\n+ * <p>\n+ * By default, ranks are computed using {@link NaturalRanking} with default\n  * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n- * The ranking algorithm can be set using a constructor argument.</p>\n+ * The ranking algorithm can be set using a constructor argument.\n  *\n  * @since 2.0\n  * @version $Id$\n@@ -58,6 +63,9 @@ public SpearmansCorrelation() {\n \n     /**\n      * Create a SpearmansCorrelation with the given ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param rankingAlgorithm ranking algorithm\n      * @since 3.1\n@@ -81,15 +89,17 @@ public SpearmansCorrelation(final RealMatrix dataMatrix) {\n     /**\n      * Create a SpearmansCorrelation with the given input data matrix\n      * and ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      * @param rankingAlgorithm ranking algorithm\n      */\n     public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n-        this.data = dataMatrix.copy();\n         this.rankingAlgorithm = rankingAlgorithm;\n-        rankTransform(data);\n+        this.data = rankTransform(dataMatrix);\n         rankCorrelation = new PearsonsCorrelation(data);\n     }\n \n@@ -125,9 +135,8 @@ public PearsonsCorrelation getRankCorrelation() {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n-        RealMatrix matrixCopy = matrix.copy();\n-        rankTransform(matrixCopy);\n+    public RealMatrix computeCorrelationMatrix(final RealMatrix matrix) {\n+        final RealMatrix matrixCopy = rankTransform(matrix);\n         return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n     }\n \n@@ -139,7 +148,7 @@ public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n+    public RealMatrix computeCorrelationMatrix(final double[][] matrix) {\n        return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n \n@@ -159,20 +168,93 @@ public double correlation(final double[] xArray, final double[] yArray) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                                    xArray.length, 2);\n         } else {\n-            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n-                    rankingAlgorithm.rank(yArray));\n+            double[] x = xArray;\n+            double[] y = yArray;\n+            if (rankingAlgorithm instanceof NaturalRanking &&\n+                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n+                final Set<Integer> nanPositions = new HashSet<Integer>();\n+\n+                nanPositions.addAll(getNaNPositions(xArray));\n+                nanPositions.addAll(getNaNPositions(yArray));\n+\n+                x = removeValues(xArray, nanPositions);\n+                y = removeValues(yArray, nanPositions);\n+            }\n+            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n         }\n     }\n \n     /**\n      * Applies rank transform to each of the columns of <code>matrix</code>\n-     * using the current <code>rankingAlgorithm</code>\n+     * using the current <code>rankingAlgorithm</code>.\n      *\n      * @param matrix matrix to transform\n+     * @return a rank-transformed matrix\n      */\n-    private void rankTransform(RealMatrix matrix) {\n+    private RealMatrix rankTransform(final RealMatrix matrix) {\n+        RealMatrix transformed = null;\n+\n+        if (rankingAlgorithm instanceof NaturalRanking &&\n+                ((NaturalRanking) rankingAlgorithm).getNanStrategy() == NaNStrategy.REMOVED) {\n+            final Set<Integer> nanPositions = new HashSet<Integer>();\n             for (int i = 0; i < matrix.getColumnDimension(); i++) {\n-            matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\n+                nanPositions.addAll(getNaNPositions(matrix.getColumn(i)));\n+            }\n+\n+            // if we have found NaN values, we have to update the matrix size\n+            if (!nanPositions.isEmpty()) {\n+                transformed = new BlockRealMatrix(matrix.getRowDimension() - nanPositions.size(),\n+                                                  matrix.getColumnDimension());\n+                for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+                    transformed.setColumn(i, removeValues(matrix.getColumn(i), nanPositions));\n+                }\n+            }\n+        }\n+\n+        if (transformed == null) {\n+            transformed = matrix.copy();\n+        }\n+\n+        for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+            transformed.setColumn(i, rankingAlgorithm.rank(transformed.getColumn(i)));\n+        }\n+\n+        return transformed;\n+    }\n+\n+    /**\n+     * Returns a list containing the indices of NaN values in the input array.\n+     *\n+     * @param input the input array\n+     * @return a list of NaN positions in the input array\n+     */\n+    private List<Integer> getNaNPositions(final double[] input) {\n+        final List<Integer> positions = new ArrayList<Integer>();\n+        for (int i = 0; i < input.length; i++) {\n+            if (Double.isNaN(input[i])) {\n+                positions.add(i);\n+            }\n+        }\n+        return positions;\n+    }\n+\n+    /**\n+     * Removes all values from the input array at the specified indices.\n+     *\n+     * @param input the input array\n+     * @param indices a set containing the indices to be removed\n+     * @return the input array without the values at the specified indices\n+     */\n+    private double[] removeValues(final double[] input, final Set<Integer> indices) {\n+        if (indices.isEmpty()) {\n+            return input;\n+        }\n+        final double[] result = new double[input.length - indices.size()];\n+        for (int i = 0, j = 0; i < input.length; i++) {\n+            if (!indices.contains(i)) {\n+                result[j++] = input[i];\n+            }\n         }\n+        return result;\n     }\n }\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}