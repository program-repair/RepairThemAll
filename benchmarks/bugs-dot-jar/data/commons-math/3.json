{
    "bug_id": 3,
    "classification": {
        "singleLine": false
    },
    "commit": "7cfbc0da",
    "failing_tests": [
        "org.apache.commons.math3.geometry.spherical.oned.ArcsSetTest"
    ],
    "files": 1,
    "jira_id": "1093",
    "linesAdd": 83,
    "linesRem": 31,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 5,
    "nb_test": 5627,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\nindex 06a8bb2ec..08ec3adcc 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n@@ -717,10 +717,10 @@ public Side side(final Arc arc) {\n             final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\n             final double arcOffset   = a[0] - syncedStart;\n             final double syncedEnd   = a[1] - arcOffset;\n-            if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\n+            if (syncedStart <= arcLength - getTolerance() || syncedEnd >= MathUtils.TWO_PI + getTolerance()) {\n                 inMinus = true;\n             }\n-            if (syncedEnd > arcLength) {\n+            if (syncedEnd >= arcLength + getTolerance()) {\n                 inPlus = true;\n             }\n         }\n@@ -749,10 +749,8 @@ public Side side(final Arc arc) {\n      */\n     public Split split(final Arc arc) {\n \n-        final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();\n-        minus.setAttribute(Boolean.FALSE);\n-        final BSPTree<Sphere1D> plus  = new BSPTree<Sphere1D>();\n-        plus.setAttribute(Boolean.FALSE);\n+        final List<Double> minus = new ArrayList<Double>();\n+        final List<Double>  plus = new ArrayList<Double>();\n \n         final double reference = FastMath.PI + arc.getInf();\n         final double arcLength = arc.getSup() - arc.getInf();\n@@ -763,51 +761,51 @@ public Split split(final Arc arc) {\n             final double syncedEnd   = a[1] - arcOffset;\n             if (syncedStart < arcLength) {\n                 // the start point a[0] is in the minus part of the arc\n-                addArcLimit(minus, a[0], true);\n+                minus.add(a[0]);\n                 if (syncedEnd > arcLength) {\n                     // the end point a[1] is past the end of the arc\n                     // so we leave the minus part and enter the plus part\n                     final double minusToPlus = arcLength + arcOffset;\n-                    addArcLimit(minus, minusToPlus, false);\n-                    addArcLimit(plus, minusToPlus, true);\n+                    minus.add(minusToPlus);\n+                    plus.add(minusToPlus);\n                     if (syncedEnd > MathUtils.TWO_PI) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the plus part of the arc and enter the minus part again\n                         final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                        addArcLimit(plus, plusToMinus, false);\n-                        addArcLimit(minus, plusToMinus, true);\n-                        addArcLimit(minus, a[1], false);\n+                        plus.add(plusToMinus);\n+                        minus.add(plusToMinus);\n+                        minus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the plus part of the arc\n-                        addArcLimit(plus, a[1], false);\n+                        plus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the minus part of the arc\n-                    addArcLimit(minus, a[1], false);\n+                    minus.add(a[1]);\n                 }\n             } else {\n                 // the start point a[0] is in the plus part of the arc\n-                addArcLimit(plus, a[0], true);\n+                plus.add(a[0]);\n                 if (syncedEnd > MathUtils.TWO_PI) {\n                     // the end point a[1] wraps around to the start of the arc\n                     // so we leave the plus part and enter the minus part\n                     final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                    addArcLimit(plus, plusToMinus, false);\n-                    addArcLimit(minus, plusToMinus, true);\n+                    plus.add(plusToMinus);\n+                    minus.add(plusToMinus);\n                     if (syncedEnd > MathUtils.TWO_PI + arcLength) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the minus part of the arc and enter the plus part again\n                         final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;\n-                        addArcLimit(minus, minusToPlus, false);\n-                        addArcLimit(plus, minusToPlus, true);\n-                        addArcLimit(plus, a[1], false);\n+                        minus.add(minusToPlus);\n+                        plus.add(minusToPlus);\n+                        plus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the minus part of the arc\n-                        addArcLimit(minus, a[1], false);\n+                        minus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the plus part of the arc\n-                    addArcLimit(plus, a[1], false);\n+                    plus.add(a[1]);\n                 }\n             }\n         }\n@@ -825,27 +824,81 @@ private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final\n         final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\n         final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\n         if (node.getCut() != null) {\n-            // we find again an already added limit,\n-            // this means we have done a full turn around the circle\n-            leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\n-        } else {\n-            // it's a new node\n+            // this should never happen\n+            throw new MathInternalError();\n+        }\n+\n         node.insertCut(limit);\n         node.setAttribute(null);\n         node.getPlus().setAttribute(Boolean.FALSE);\n         node.getMinus().setAttribute(Boolean.TRUE);\n-        }\n+\n     }\n \n     /** Create a split part.\n-     * @param tree BSP tree containing the limit angles of the split part\n+     * <p>\n+     * As per construction, the list of limit angles is known to have\n+     * an even number of entries, with start angles at even indices and\n+     * end angles at odd indices.\n+     * </p>\n+     * @param limits limit angles of the split part\n      * @return split part (may be null)\n      */\n-    private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {\n-        if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {\n+    private ArcsSet createSplitPart(final List<Double> limits) {\n+        if (limits.isEmpty()) {\n+            return null;\n+        } else {\n+\n+            // collapse close limit angles\n+            for (int i = 0; i < limits.size(); ++i) {\n+                final int    j  = (i + 1) % limits.size();\n+                final double lA = limits.get(i);\n+                final double lB = MathUtils.normalizeAngle(limits.get(j), lA);\n+                if (FastMath.abs(lB - lA) <= getTolerance()) {\n+                    // the two limits are too close to each other, we remove both of them\n+                    if (j > 0) {\n+                        // regular case, the two entries are consecutive ones\n+                        limits.remove(j);\n+                        limits.remove(i);\n+                        i = i - 1;\n+                    } else {\n+                        // special case, i the the last entry and j is the first entry\n+                        // we have wrapped around list end\n+                        final double lEnd   = limits.remove(limits.size() - 1);\n+                        final double lStart = limits.remove(0);\n+                        if (limits.isEmpty()) {\n+                            // the ends were the only limits, is it a full circle or an empty circle?\n+                            if (lEnd - lStart > FastMath.PI) {\n+                                // it was full circle\n+                                return new ArcsSet(new BSPTree<Sphere1D>(Boolean.TRUE), getTolerance());\n+                            } else {\n+                                // it was an empty circle\n                                 return null;\n+                            }\n                         } else {\n+                            // we have removed the first interval start, so our list\n+                            // currently starts with an interval end, which is wrong\n+                            // we need to move this interval end to the end of the list\n+                            limits.add(limits.remove(0) + MathUtils.TWO_PI);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // build the tree by adding all angular sectors\n+            BSPTree<Sphere1D> tree = new BSPTree<Sphere1D>(Boolean.FALSE);\n+            for (int i = 0; i < limits.size() - 1; i += 2) {\n+                addArcLimit(tree, limits.get(i),     true);\n+                addArcLimit(tree, limits.get(i + 1), false);\n+            }\n+\n+            if (tree.getCut() == null) {\n+                // we did not insert anything\n+                return null;\n+            }\n+\n             return new ArcsSet(tree, getTolerance());\n+\n         }\n     }\n \n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}