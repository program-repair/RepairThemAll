{
    "bug_id": 11,
    "classification": {
        "singleLine": false
    },
    "commit": "76b7413d",
    "failing_tests": [
        "org.apache.commons.math4.random.CorrelatedRandomVectorGeneratorTest",
        "org.apache.commons.math4.util.ResizableDoubleArrayTest"
    ],
    "files": 1,
    "jira_id": "757",
    "linesAdd": 131,
    "linesRem": 497,
    "nb_error": 0,
    "nb_failure": 2,
    "nb_skipped": 3,
    "nb_test": 5850,
    "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\nindex b0dd132d2..09fd7482b 100644\n--- a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n@@ -21,21 +21,15 @@\n \n import org.apache.commons.math4.exception.MathIllegalArgumentException;\n import org.apache.commons.math4.exception.MathIllegalStateException;\n-import org.apache.commons.math4.exception.MathInternalError;\n import org.apache.commons.math4.exception.NotStrictlyPositiveException;\n import org.apache.commons.math4.exception.NullArgumentException;\n import org.apache.commons.math4.exception.NumberIsTooSmallException;\n import org.apache.commons.math4.exception.util.LocalizedFormats;\n \n /**\n- * <p>\n  * A variable length {@link DoubleArray} implementation that automatically\n  * handles expanding and contracting its internal storage array as elements\n  * are added and removed.\n- * </p>\n- * <h3>Important note: Usage should not assume that this class is thread-safe\n- * even though some of the methods are {@code synchronized}.\n- * This qualifier will be dropped in the next major release (4.0).</h3>\n  * <p>\n  * The internal storage array starts with capacity determined by the\n  * {@code initialCapacity} property, which can be set by the constructor.\n@@ -51,7 +45,6 @@\n  * locations added).\n  * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default\n  * {@code expansionFactor} is 2.\n- * </p>\n  * <p>\n  * The {@link #addElementRolling(double)} method adds a new element to the end\n  * of the internal storage array and adjusts the \"usable window\" of the\n@@ -71,26 +64,16 @@\n  * {@code contractionFactor.}  If the {@code expansionMode}\n  * is {@code ADDITIVE}, the number of excess storage locations\n  * is compared to {@code contractionFactor}.\n- * </p>\n  * <p>\n  * To avoid cycles of expansions and contractions, the\n  * {@code expansionFactor} must not exceed the {@code contractionFactor}.\n  * Constructors and mutators for both of these properties enforce this\n  * requirement, throwing a {@code MathIllegalArgumentException} if it is\n  * violated.\n- * </p>\n+ * <p>\n+ * <b>Note:</b> this class is <b>NOT</b> thread-safe.\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-    /** Additive expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int ADDITIVE_MODE = 1;\n-    /** Multiplicative expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int MULTIPLICATIVE_MODE = 0;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3485529955529426875L;\n \n@@ -98,6 +81,8 @@\n     private static final int DEFAULT_INITIAL_CAPACITY = 16;\n     /** Default value for array size modifier. */\n     private static final double DEFAULT_EXPANSION_FACTOR = 2.0;\n+    /** Default value for expansion mode. */\n+    private static final ExpansionMode DEFAULT_EXPANSION_MODE = ExpansionMode.MULTIPLICATIVE;\n     /**\n      * Default value for the difference between {@link #contractionCriterion}\n      * and {@link #expansionFactor}.\n@@ -109,23 +94,22 @@\n      * contracted to fit the number of elements contained in the element\n      *  array + 1.\n      */\n-    private double contractionCriterion = 2.5;\n+    private final double contractionCriterion;\n \n     /**\n      * The expansion factor of the array.  When the array needs to be expanded,\n-     * the new array size will be\n-     * {@code internalArray.length * expansionFactor}\n-     * if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or\n+     * the new array size will be {@code internalArray.length * expansionFactor}\n+     * if {@code expansionMode} is set to MULTIPLICATIVE, or\n      * {@code internalArray.length + expansionFactor} if\n-     * {@code expansionMode} is set to ADDITIVE_MODE.\n+     * {@code expansionMode} is set to ADDITIVE.\n      */\n-    private double expansionFactor = 2.0;\n+    private final double expansionFactor;\n \n     /**\n      * Determines whether array expansion by {@code expansionFactor}\n      * is additive or multiplicative.\n      */\n-    private ExpansionMode expansionMode = ExpansionMode.MULTIPLICATIVE;\n+    private final ExpansionMode expansionMode;\n \n     /**\n      * The internal storage array.\n@@ -171,6 +155,7 @@ public ResizableDoubleArray() {\n \n     /**\n      * Creates an instance with the specified initial capacity.\n+     * <p>\n      * Other properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n@@ -180,8 +165,7 @@ public ResizableDoubleArray() {\n      * @param initialCapacity Initial size of the internal storage array.\n      * @throws MathIllegalArgumentException if {@code initialCapacity <= 0}.\n      */\n-    public ResizableDoubleArray(int initialCapacity)\n-        throws MathIllegalArgumentException {\n+    public ResizableDoubleArray(int initialCapacity) throws MathIllegalArgumentException {\n         this(initialCapacity, DEFAULT_EXPANSION_FACTOR);\n     }\n \n@@ -189,6 +173,7 @@ public ResizableDoubleArray(int initialCapacity)\n      * Creates an instance from an existing {@code double[]} with the\n      * initial capacity and numElements corresponding to the size of\n      * the supplied {@code double[]} array.\n+     * <p>\n      * If the supplied array is null, a new empty array with the default\n      * initial capacity will be created.\n      * The input array is copied, not referenced.\n@@ -207,177 +192,66 @@ public ResizableDoubleArray(double[] initialArray) {\n         this(DEFAULT_INITIAL_CAPACITY,\n              DEFAULT_EXPANSION_FACTOR,\n              DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR,\n-             ExpansionMode.MULTIPLICATIVE,\n+             DEFAULT_EXPANSION_MODE,\n              initialArray);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity\n      * and expansion factor.\n+     * <p>\n      * The remaining properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n      *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n      * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initial capacity\n-     * and expansion factor.\n-     * The remaining properties take default values:\n-     * <ul>\n-     *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n-     *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n-     * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @throws MathIllegalArgumentException if parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             DEFAULT_CONTRACTION_DELTA + expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initialCapacity,\n-     * expansionFactor, and contractionCriterion.\n-     * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     *  <li>{@code contractionCriterion >= expansionFactor}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @param contractionCriteria Contraction criteria.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor,\n-                                float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor,\n-             (double) contractionCriteria);\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor) throws MathIllegalArgumentException {\n+        this(initialCapacity, expansionFactor, DEFAULT_CONTRACTION_DELTA + expansionFactor);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity,\n      * expansion factor, and contraction criteria.\n+     * <p>\n      * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      *  <li>{@code contractionCriterion >= expansionFactor}</li>\n      * </ul>\n      *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param initialCapacity Initial size of the internal storage array.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criterion.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor,\n-                                double contractionCriterion)\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor, double contractionCriterion)\n         throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriterion,\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-    }\n-\n-    /**\n-     * <p>\n-     * Create a ResizableArray with the specified properties.</p>\n-     * <p>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     * <li><code>initialCapacity > 0</code></li>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n-     * </li>\n-     * </ul></p>\n-     *\n-     * @param initialCapacity the initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this\n-     *                        parameter\n-     * @param contractionCriteria the contraction Criteria\n-     * @param expansionMode  the expansion mode\n-     * @throws MathIllegalArgumentException if parameters are not valid\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double,ExpansionMode,double[])}\n-     * instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n-            float contractionCriteria, int expansionMode) throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriteria,\n-             expansionMode == ADDITIVE_MODE ?\n-             ExpansionMode.ADDITIVE :\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-        // XXX Just ot retain the expected failure in a unit test.\n-        // With the new \"enum\", that test will become obsolete.\n-        setExpansionMode(expansionMode);\n+        this(initialCapacity, expansionFactor, contractionCriterion, DEFAULT_EXPANSION_MODE, null);\n     }\n \n     /**\n      * Creates an instance with the specified properties.\n      * <br/>\n-     * Throws MathIllegalArgumentException if the following conditions are\n-     * not met:\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n@@ -385,12 +259,12 @@ public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criteria.\n      * @param expansionMode Expansion mode.\n      * @param data Initial contents of the array.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n+     * @throws NullArgumentException if expansionMode is null\n      */\n     public ResizableDoubleArray(int initialCapacity,\n                                 double expansionFactor,\n@@ -403,6 +277,7 @@ public ResizableDoubleArray(int initialCapacity,\n                                                    initialCapacity);\n         }\n         checkContractExpand(contractionCriterion, expansionFactor);\n+        MathUtils.checkNotNull(expansionMode);\n \n         this.expansionFactor = expansionFactor;\n         this.contractionCriterion = contractionCriterion;\n@@ -417,19 +292,25 @@ public ResizableDoubleArray(int initialCapacity,\n     }\n \n     /**\n-     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n-     * fresh copy of the original. Needs to acquire synchronization lock\n-     * on original.  Original may not be null; otherwise a {@link NullArgumentException}\n-     * is thrown.\n+     * Copy constructor.\n+     * <p>\n+     * Creates a new ResizableDoubleArray that is a deep, fresh copy of the original.\n+     * Original may not be null; otherwise a {@link NullArgumentException} is thrown.\n      *\n      * @param original array to copy\n      * @exception NullArgumentException if original is null\n      * @since 2.0\n      */\n-    public ResizableDoubleArray(ResizableDoubleArray original)\n+    public ResizableDoubleArray(final ResizableDoubleArray original)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(original);\n-        copy(original, this);\n+        this.contractionCriterion = original.contractionCriterion;\n+        this.expansionFactor = original.expansionFactor;\n+        this.expansionMode = original.expansionMode;\n+        this.internalArray = new double[original.internalArray.length];\n+        System.arraycopy(original.internalArray, 0, this.internalArray, 0, this.internalArray.length);\n+        this.numElements = original.numElements;\n+        this.startIndex = original.startIndex;\n     }\n \n     /**\n@@ -438,7 +319,7 @@ public ResizableDoubleArray(ResizableDoubleArray original)\n      * @param value Value to be added to end of array.\n      */\n     @Override\n-    public synchronized void addElement(double value) {\n+    public void addElement(final double value) {\n         if (internalArray.length <= startIndex + numElements) {\n             expand();\n         }\n@@ -452,7 +333,7 @@ public synchronized void addElement(double value) {\n      * @since 2.2\n      */\n     @Override\n-    public synchronized void addElements(double[] values) {\n+    public void addElements(final double[] values) {\n         final double[] tempArray = new double[numElements + values.length + 1];\n         System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n         System.arraycopy(values, 0, tempArray, numElements, values.length);\n@@ -462,23 +343,21 @@ public synchronized void addElements(double[] values) {\n     }\n \n     /**\n-     * <p>\n      * Adds an element to the end of the array and removes the first\n      * element in the array.  Returns the discarded first element.\n+     * <p>\n      * The effect is similar to a push operation in a FIFO queue.\n-     * </p>\n      * <p>\n      * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n      * and addElementRolling(5) is invoked, the result is an array containing\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n-     * </p>\n      *\n      * @param value Value to be added to the array.\n      * @return the value which has been discarded or \"pushed\" out of the array\n      * by this rolling insert.\n      */\n     @Override\n-    public synchronized double addElementRolling(double value) {\n+    public double addElementRolling(double value) {\n         double discarded = internalArray[startIndex];\n \n         if ((startIndex + (numElements + 1)) > internalArray.length) {\n@@ -498,20 +377,19 @@ public synchronized double addElementRolling(double value) {\n     }\n \n     /**\n-     * Substitutes <code>value</code> for the most recently added value.\n+     * Substitutes {@code value} for the most recently added value.\n+     * <p>\n      * Returns the value that has been replaced. If the array is empty (i.e.\n-     * if {@link #numElements} is zero), an IllegalStateException is thrown.\n+     * if {@link #numElements} is zero), an MathIllegalStateException is thrown.\n      *\n      * @param value New value to substitute for the most recently added value\n      * @return the value that has been replaced in the array.\n      * @throws MathIllegalStateException if the array is empty\n      * @since 2.0\n      */\n-    public synchronized double substituteMostRecentElement(double value)\n-        throws MathIllegalStateException {\n+    public double substituteMostRecentElement(double value) throws MathIllegalStateException {\n         if (numElements < 1) {\n-            throw new MathIllegalStateException(\n-                    LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n+            throw new MathIllegalStateException(LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n         }\n \n         final int substIndex = startIndex + (numElements - 1);\n@@ -522,25 +400,6 @@ public synchronized double substituteMostRecentElement(double value)\n         return discarded;\n     }\n \n-    /**\n-     * Checks the expansion factor and the contraction criterion and throws an\n-     * IllegalArgumentException if the contractionCriteria is less than the\n-     * expansionCriteria\n-     *\n-     * @param expansion factor to be checked\n-     * @param contraction criteria to be checked\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     * the expansionCriteria.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #checkContractExpand(double,double)} instead.\n-     */\n-    @Deprecated\n-    protected void checkContractExpand(float contraction, float expansion)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand((double) contraction,\n-                            (double) expansion);\n-    }\n-\n     /**\n      * Checks the expansion factor and the contraction criterion and raises\n      * an exception if the contraction criterion is smaller than the\n@@ -553,9 +412,7 @@ protected void checkContractExpand(float contraction, float expansion)\n      * @throws NumberIsTooSmallException if {@code expansion <= 1 }.\n      * @since 3.1\n      */\n-    protected void checkContractExpand(double contraction,\n-                                       double expansion)\n-        throws NumberIsTooSmallException {\n+    protected void checkContractExpand(double contraction, double expansion) throws NumberIsTooSmallException {\n         if (contraction < expansion) {\n             final NumberIsTooSmallException e = new NumberIsTooSmallException(contraction, 1, true);\n             e.getContext().addMessage(LocalizedFormats.CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR,\n@@ -582,17 +439,16 @@ protected void checkContractExpand(double contraction,\n      * Clear the array contents, resetting the number of elements to zero.\n      */\n     @Override\n-    public synchronized void clear() {\n+    public void clear() {\n         numElements = 0;\n         startIndex = 0;\n     }\n \n     /**\n-     * Contracts the storage array to the (size of the element set) + 1 - to\n-     * avoid a zero length array. This function also resets the startIndex to\n-     * zero.\n+     * Contracts the storage array to the (size of the element set) + 1 - to avoid\n+     * a zero length array. This function also resets the startIndex to zero.\n      */\n-    public synchronized void contract() {\n+    public void contract() {\n         final double[] tempArray = new double[numElements + 1];\n \n         // Copy and swap - copy only the element array from the src array.\n@@ -604,48 +460,45 @@ public synchronized void contract() {\n     }\n \n     /**\n-     * Discards the <code>i</code> initial elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardFrontElements(2)</code> will cause the first two elements\n-     * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} initial elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardFrontElements(2)} will cause the first two elements\n+     * to be discarded, leaving 3,4 in the array.\n      *\n      * @param i  the number of elements to discard from the front of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardFrontElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardFrontElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,true);\n     }\n \n     /**\n-     * Discards the <code>i</code> last elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardMostRecentElements(2)</code> will cause the last two elements\n-     * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} last elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardMostRecentElements(2)} will cause the last two elements\n+     * to be discarded, leaving 1,2 in the array.\n      *\n      * @param i  the number of elements to discard from the end of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardMostRecentElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,false);\n     }\n \n     /**\n-     * Discards the <code>i</code> first or last elements of the array,\n-     * depending on the value of <code>front</code>.\n+     * Discards the {@code i} first or last elements of the array,\n+     * depending on the value of {@code front}.\n+     * <p>\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n+     * {@code discardExtremeElements(2,false)} will cause the last two elements\n      * to be discarded, leaving 1,2 in the array.\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n+     * {@code discardExtremeElements(2,true)} will cause the first two elements\n      * to be discarded, leaving 3,4 in the array.\n-     * Throws illegalArgumentException\n-     * if i exceeds numElements.\n      *\n      * @param i  the number of elements to discard from the front/end of the array\n      * @param front true if elements are to be discarded from the front\n@@ -654,9 +507,7 @@ public synchronized void discardMostRecentElements(int i)\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    private synchronized void discardExtremeElements(int i,\n-                                                     boolean front)\n-        throws MathIllegalArgumentException {\n+    private void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\n         if (i > numElements) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n@@ -680,13 +531,12 @@ private synchronized void discardExtremeElements(int i,\n     /**\n      * Expands the internal storage array using the expansion factor.\n      * <p>\n-     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n-     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n-     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n-     * after expansion will be <code>internalArray.length + expansionFactor</code>\n-     * </p>\n+     * If {@code expansionMode} is set to MULTIPLICATIVE,\n+     * the new array size will be {@code internalArray.length * expansionFactor}.\n+     * If {@code expansionMode} is set to ADDITIVE, the length\n+     * after expansion will be {@code internalArray.length + expansionFactor}.\n      */\n-    protected synchronized void expand() {\n+    protected void expand() {\n         // notice the use of FastMath.ceil(), this guarantees that we will always\n         // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n@@ -710,41 +560,22 @@ protected synchronized void expand() {\n      *\n      * @param size Size of the new internal storage array.\n      */\n-    private synchronized void expandTo(int size) {\n+    private void expandTo(int size) {\n         final double[] tempArray = new double[size];\n         // Copy and swap\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n         internalArray = tempArray;\n     }\n \n-    /**\n-     * The contraction criteria defines when the internal array will contract\n-     * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n-     * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n-     *\n-     * @return the contraction criteria used to reclaim memory.\n-     * @deprecated As of 3.1. Please use {@link #getContractionCriterion()}\n-     * instead.\n-     */\n-    @Deprecated\n-    public float getContractionCriteria() {\n-        return (float) getContractionCriterion();\n-    }\n-\n     /**\n      * The contraction criterion defines when the internal array will contract\n      * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n+     * <p>\n+     * If the {@code expansionMode} is {@code MULTIPLICATIVE},\n      * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n+     * and {@code numElements} exceeds {@code contractionFactor}.\n+     * If the {@code expansionMode} is {@code ADDITIVE}, the\n+     * number of excess storage locations is compared to {@code contractionFactor}.\n      *\n      * @return the contraction criterion used to reclaim memory.\n      * @since 3.1\n@@ -754,15 +585,15 @@ public double getContractionCriterion() {\n     }\n \n     /**\n-     * Returns the element at the specified index\n+     * Returns the element at the specified index.\n      *\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n-     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n-     * zero or is greater than <code>getNumElements() - 1</code>.\n+     * @throws ArrayIndexOutOfBoundsException if {@code index} is less than\n+     * zero or is greater than {@code getNumElements() - 1}.\n      */\n     @Override\n-    public synchronized double getElement(int index) {\n+    public double getElement(int index) {\n         if (index >= numElements) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         } else if (index >= 0) {\n@@ -773,14 +604,15 @@ public synchronized double getElement(int index) {\n     }\n \n      /**\n-     * Returns a double array containing the elements of this\n-     * <code>ResizableArray</code>.  This method returns a copy, not a\n-     * reference to the underlying array, so that changes made to the returned\n-     *  array have no effect on this <code>ResizableArray.</code>\n+     * Returns a double array containing the elements of this ResizableArray.\n+     * <p>\n+     * This method returns a copy, not a reference to the underlying array,\n+     * so that changes made to the returned array have no effect on this ResizableArray.\n+     *\n      * @return the double array.\n      */\n     @Override\n-    public synchronized double[] getElements() {\n+    public double[] getElements() {\n         final double[] elementArray = new double[numElements];\n         System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n         return elementArray;\n@@ -788,20 +620,18 @@ public synchronized double getElement(int index) {\n \n     /**\n      * The expansion factor controls the size of a new array when an array\n-     * needs to be expanded.  The <code>expansionMode</code>\n-     * determines whether the size of the array is multiplied by the\n-     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n-     * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n-     * storage locations added).  The default <code>expansionMode</code> is\n-     * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n-     * is 2.0.\n+     * needs to be expanded.\n+     * <p>\n+     * The {@code expansionMode} determines whether the size of the array\n+     * is multiplied by the {@code expansionFactor} (MULTIPLICATIVE) or if\n+     * the expansion is additive (ADDITIVE -- {@code expansionFactor}\n+     * storage locations added).  The default {@code expansionMode} is\n+     * MULTIPLICATIVE and the default {@code expansionFactor} is 2.0.\n      *\n      * @return the expansion factor of this expandable double array\n-     * @deprecated As of 3.1. Return type will be changed to \"double\" in 4.0.\n      */\n-    @Deprecated\n-    public float getExpansionFactor() {\n-        return (float) expansionFactor;\n+    public double getExpansionFactor() {\n+        return expansionFactor;\n     }\n \n     /**\n@@ -809,33 +639,9 @@ public float getExpansionFactor() {\n      * array grows additively or multiplicatively when it is expanded.\n      *\n      * @return the expansion mode.\n-     * @deprecated As of 3.1. Return value to be changed to\n-     * {@link ExpansionMode} in 4.0.\n-     */\n-    @Deprecated\n-    public int getExpansionMode() {\n-        switch (expansionMode) {\n-        case MULTIPLICATIVE:\n-            return MULTIPLICATIVE_MODE;\n-        case ADDITIVE:\n-            return ADDITIVE_MODE;\n-        default:\n-            throw new MathInternalError(); // Should never happen.\n-        }\n-    }\n-\n-    /**\n-     * Notice the package scope on this method.   This method is simply here\n-     * for the JUnit test, it allows us check if the expansion is working\n-     * properly after a number of expansions.  This is not meant to be a part\n-     * of the public interface of this class.\n-     *\n-     * @return the length of the internal storage array.\n-     * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.\n      */\n-    @Deprecated\n-    synchronized int getInternalLength() {\n-        return internalArray.length;\n+    public ExpansionMode getExpansionMode() {\n+        return expansionMode;\n     }\n \n     /**\n@@ -858,41 +664,23 @@ public int getCapacity() {\n      * @return the number of elements.\n      */\n     @Override\n-    public synchronized int getNumElements() {\n+    public int getNumElements() {\n         return numElements;\n     }\n \n-    /**\n-     * Returns the internal storage array.  Note that this method returns\n-     * a reference to the internal storage array, not a copy, and to correctly\n-     * address elements of the array, the <code>startIndex</code> is\n-     * required (available via the {@link #start} method).  This method should\n-     * only be used in cases where copying the internal array is not practical.\n-     * The {@link #getElements} method should be used in all other cases.\n-     *\n-     *\n-     * @return the internal storage array used by this object\n-     * @since 2.0\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized double[] getInternalValues() {\n-        return internalArray;\n-    }\n-\n     /**\n      * Provides <em>direct</em> access to the internal storage array.\n      * Please note that this method returns a reference to this object's\n      * storage array, not a copy.\n-     * <br/>\n+     * <p>\n      * To correctly address elements of the array, the \"start index\" is\n      * required (available via the {@link #getStartIndex() getStartIndex}\n      * method.\n-     * <br/>\n+     * <p>\n      * This method should only be used to avoid copying the internal array.\n      * The returned value <em>must</em> be used for reading only; other\n      * uses could lead to this object becoming inconsistent.\n-     * <br/>\n+     * <p>\n      * The {@link #getElements} method has no such limitation since it\n      * returns a copy of this array's addressable elements.\n      *\n@@ -907,6 +695,7 @@ public synchronized int getNumElements() {\n      * Returns the \"start index\" of the internal array.\n      * This index is the position of the first addressable element in the\n      * internal storage array.\n+     * <p>\n      * The addressable elements in the array are at indices contained in\n      * the interval [{@link #getStartIndex()},\n      *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n@@ -918,23 +707,6 @@ protected int getStartIndex() {\n         return startIndex;\n     }\n \n-    /**\n-     * Sets the contraction criteria.\n-     *\n-     * @param contractionCriteria contraction criteria\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     *         the expansionCriteria.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setContractionCriteria(float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand(contractionCriteria, getExpansionFactor());\n-        synchronized(this) {\n-            this.contractionCriterion = contractionCriteria;\n-        }\n-    }\n-\n     /**\n      * Performs an operation on the addressable elements of the array.\n      *\n@@ -943,30 +715,24 @@ public void setContractionCriteria(float contractionCriteria)\n      * @since 3.1\n      */\n     public double compute(MathArrays.Function f) {\n-        final double[] array;\n-        final int start;\n-        final int num;\n-        synchronized(this) {\n-            array = internalArray;\n-            start = startIndex;\n-            num   = numElements;\n-        }\n-        return f.evaluate(array, start, num);\n+        return f.evaluate(internalArray, startIndex, numElements);\n     }\n \n     /**\n-     * Sets the element at the specified index.  If the specified index is greater than\n-     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n-     * is increased to <code>index +1</code> and additional storage is allocated\n-     * (if necessary) for the new element and all  (uninitialized) elements\n-     * between the new element and the previous end of the array).\n+     * Sets the element at the specified index.\n+     * <p>\n+     * If the specified index is greater than {@code getNumElements() - 1},\n+     * the {@code numElements} property is increased to {@code index +1}\n+     * and additional storage is allocated (if necessary) for the new element and\n+     * all (uninitialized) elements between the new element and the previous end\n+     * of the array).\n      *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n      * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\n      */\n     @Override\n-    public synchronized void setElement(int index, double value) {\n+    public void setElement(int index, double value) {\n         if (index < 0) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         }\n@@ -979,93 +745,18 @@ public synchronized void setElement(int index, double value) {\n         internalArray[startIndex + index] = value;\n     }\n \n-    /**\n-     * Sets the expansionFactor.  Throws IllegalArgumentException if the\n-     * the following conditions are not met:\n-     * <ul>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * </ul>\n-     * @param expansionFactor the new expansion factor value.\n-     * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\n-     * than contractionFactor\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\n-        checkContractExpand(getContractionCriterion(), expansionFactor);\n-        // The check above verifies that the expansion factor is > 1.0;\n-        synchronized(this) {\n-            this.expansionFactor = expansionFactor;\n-        }\n-    }\n-\n-    /**\n-     * Sets the <code>expansionMode</code>. The specified value must be one of\n-     * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n-     *\n-     * @param expansionMode The expansionMode to set.\n-     * @throws MathIllegalArgumentException if the specified mode value is not valid.\n-     * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n-     */\n-    @Deprecated\n-    public void setExpansionMode(int expansionMode)\n-        throws MathIllegalArgumentException {\n-        if (expansionMode != MULTIPLICATIVE_MODE &&\n-            expansionMode != ADDITIVE_MODE) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode,\n-                                                   MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n-                                                   ADDITIVE_MODE, \"ADDITIVE_MODE\");\n-        }\n-        synchronized(this) {\n-            if (expansionMode == MULTIPLICATIVE_MODE) {\n-                setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n-            } else if (expansionMode == ADDITIVE_MODE) {\n-                setExpansionMode(ExpansionMode.ADDITIVE);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets the {@link ExpansionMode expansion mode}.\n-     *\n-     * @param expansionMode Expansion mode to use for resizing the array.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionMode(ExpansionMode expansionMode) {\n-        this.expansionMode = expansionMode;\n-    }\n-\n-    /**\n-     * Sets the initial capacity.  Should only be invoked by constructors.\n-     *\n-     * @param initialCapacity of the array\n-     * @throws MathIllegalArgumentException if <code>initialCapacity</code> is not\n-     * positive.\n-     * @deprecated As of 3.1, this is a no-op.\n-     */\n-    @Deprecated\n-    protected void setInitialCapacity(int initialCapacity)\n-        throws MathIllegalArgumentException {\n-        // Body removed in 3.1.\n-    }\n-\n     /**\n      * This function allows you to control the number of elements contained\n      * in this array, and can be used to \"throw out\" the last n values in an\n      * array. This function will also expand the internal array as needed.\n      *\n      * @param i a new number of elements\n-     * @throws MathIllegalArgumentException if <code>i</code> is negative.\n+     * @throws MathIllegalArgumentException if {@code i} is negative.\n      */\n-    public synchronized void setNumElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void setNumElements(int i) throws MathIllegalArgumentException {\n         // If index is negative thrown an error.\n         if (i < 0) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.INDEX_NOT_POSITIVE,\n-                    i);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INDEX_NOT_POSITIVE, i);\n         }\n \n         // Test the new num elements, check to see if the array needs to be\n@@ -1085,7 +776,7 @@ public synchronized void setNumElements(int i)\n      *\n      * @return true if array satisfies the contraction criteria\n      */\n-    private synchronized boolean shouldContract() {\n+    private boolean shouldContract() {\n         if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n             return (internalArray.length / ((float) numElements)) > contractionCriterion;\n         } else {\n@@ -1093,57 +784,6 @@ private synchronized boolean shouldContract() {\n         }\n     }\n \n-    /**\n-     * Returns the starting index of the internal array.  The starting index is\n-     * the position of the first addressable element in the internal storage\n-     * array.  The addressable elements in the array are <code>\n-     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n-     * </code>\n-     *\n-     * @return the starting index.\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized int start() {\n-        return startIndex;\n-    }\n-\n-    /**\n-     * <p>Copies source to dest, copying the underlying data, so dest is\n-     * a new, independent copy of source.  Does not contract before\n-     * the copy.</p>\n-     *\n-     * <p>Obtains synchronization locks on both source and dest\n-     * (in that order) before performing the copy.</p>\n-     *\n-     * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}\n-     * is thrown</p>\n-     *\n-     * @param source ResizableDoubleArray to copy\n-     * @param dest ResizableArray to replace with a copy of the source array\n-     * @exception NullArgumentException if either source or dest is null\n-     * @since 2.0\n-     *\n-     */\n-    public static void copy(ResizableDoubleArray source,\n-                            ResizableDoubleArray dest)\n-        throws NullArgumentException {\n-        MathUtils.checkNotNull(source);\n-        MathUtils.checkNotNull(dest);\n-        synchronized(source) {\n-           synchronized(dest) {\n-               dest.contractionCriterion = source.contractionCriterion;\n-               dest.expansionFactor = source.expansionFactor;\n-               dest.expansionMode = source.expansionMode;\n-               dest.internalArray = new double[source.internalArray.length];\n-               System.arraycopy(source.internalArray, 0, dest.internalArray,\n-                       0, dest.internalArray.length);\n-               dest.numElements = source.numElements;\n-               dest.startIndex = source.startIndex;\n-           }\n-       }\n-    }\n-\n     /**\n      * Returns a copy of the ResizableDoubleArray.  Does not contract before\n      * the copy, so the returned object is an exact copy of this.\n@@ -1152,10 +792,8 @@ public static void copy(ResizableDoubleArray source,\n      * properties as this\n      * @since 2.0\n      */\n-    public synchronized ResizableDoubleArray copy() {\n-        final ResizableDoubleArray result = new ResizableDoubleArray();\n-        copy(this, result);\n-        return result;\n+    public ResizableDoubleArray copy() {\n+        return new ResizableDoubleArray(this);\n     }\n \n     /**\n@@ -1175,8 +813,6 @@ public boolean equals(Object object) {\n         if (object instanceof ResizableDoubleArray == false) {\n             return false;\n         }\n-        synchronized(this) {\n-            synchronized(object) {\n         boolean result = true;\n         final ResizableDoubleArray other = (ResizableDoubleArray) object;\n         result = result && (other.contractionCriterion == contractionCriterion);\n@@ -1190,8 +826,6 @@ public boolean equals(Object object) {\n             return Arrays.equals(internalArray, other.internalArray);\n         }\n     }\n-        }\n-    }\n \n     /**\n      * Returns a hash code consistent with equals.\n@@ -1200,7 +834,7 @@ public boolean equals(Object object) {\n      * @since 2.0\n      */\n     @Override\n-    public synchronized int hashCode() {\n+    public int hashCode() {\n         final int[] hashData = new int[6];\n         hashData[0] = Double.valueOf(expansionFactor).hashCode();\n         hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}