{
    "bug_id": 141,
    "classification": {
        "singleLine": false
    },
    "commit": "b2e24119",
    "failing_tests": [
        "org.apache.commons.math.distribution.AbstractRealDistributionTest"
    ],
    "files": 1,
    "jira_id": "699",
    "linesAdd": 62,
    "linesRem": 32,
    "nb_error": 2,
    "nb_failure": 0,
    "nb_skipped": 1,
    "nb_test": 3145,
    "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\nindex a37d2d2b5..d83837d71 100644\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n@@ -20,7 +20,6 @@\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n-import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n@@ -74,45 +72,76 @@ public double inverseCumulativeProbability(final double p) throws OutOfRangeExce\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple root finding using bracketing and default solver.\n-        // subclasses can override if there is a better method.\n-        UnivariateFunction rootFindingFunction =\n-            new UnivariateFunction() {\n-            public double value(double x) {\n+        double lowerBound = getSupportLowerBound();\n+        if (p == 0.0) {\n+            return lowerBound;\n+        }\n+\n+        double upperBound = getSupportUpperBound();\n+        if (p == 1.0) {\n+            return upperBound;\n+        }\n+\n+        final double mu = getNumericalMean();\n+        final double sig = FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies;\n+        chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                             Double.isInfinite(sig) || Double.isNaN(sig));\n+\n+        if (lowerBound == Double.NEGATIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n+            } else {\n+                lowerBound = -1.0;\n+                while (cumulativeProbability(lowerBound) >= p) {\n+                    lowerBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        if (upperBound == Double.POSITIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                upperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n+            } else {\n+                upperBound = 1.0;\n+                while (cumulativeProbability(upperBound) < p) {\n+                    upperBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        final UnivariateFunction toSolve = new UnivariateFunction() {\n+\n+            public double value(final double x) {\n                 return cumulativeProbability(x) - p;\n             }\n         };\n \n-        // Try to bracket root, test domain endpoints if this fails\n-        double lowerBound = getDomainLowerBound(p);\n-        double upperBound = getDomainUpperBound(p);\n-        double[] bracket = null;\n-        try {\n-            bracket = UnivariateRealSolverUtils.bracket(\n-                    rootFindingFunction, getInitialDomain(p),\n-                    lowerBound, upperBound);\n-        } catch (NumberIsTooLargeException ex) {\n-            /*\n-             * Check domain endpoints to see if one gives value that is within\n-             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n-             * case if density has bounded support and p is 0 or 1).\n-             */\n-            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n-                return lowerBound;\n+        double x = UnivariateRealSolverUtils.solve(toSolve,\n+                                                   lowerBound,\n+                                                   upperBound,\n+                                                   getSolverAbsoluteAccuracy());\n+\n+        if (!isSupportConnected()) {\n+            /* Test for plateau. */\n+            final double dx = getSolverAbsoluteAccuracy();\n+            if (x - dx >= getSupportLowerBound()) {\n+                double px = cumulativeProbability(x);\n+                if (cumulativeProbability(x - dx) == px) {\n+                    upperBound = x;\n+                    while (upperBound - lowerBound > dx) {\n+                        final double midPoint = 0.5 * (lowerBound + upperBound);\n+                        if (cumulativeProbability(midPoint) < px) {\n+                            lowerBound = midPoint;\n+                        } else {\n+                            upperBound = midPoint;\n+                        }\n                     }\n-            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n                     return upperBound;\n                 }\n-            // Failed bracket convergence was not because of corner solution\n-            throw new MathInternalError(ex);\n             }\n-\n-        // find root\n-        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n-                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n-                // absolute accuracy different from the default.\n-                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n-        return root;\n+        }\n+        return x;\n     }\n \n     /**\n",
    "project": "commons-math"
}