{
    "bug_id": 28,
    "classification": {
        "singleLine": false
    },
    "commit": "26a61077",
    "failing_tests": [
        "org.apache.commons.math.optimization.fitting.GaussianFitterTest"
    ],
    "files": 1,
    "jira_id": "519",
    "linesAdd": 85,
    "linesRem": 52,
    "nb_error": 1,
    "nb_failure": 0,
    "nb_skipped": 1,
    "nb_test": 2325,
    "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex 725b5ca84..e1b54f49e 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -21,10 +21,12 @@\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.function.Gaussian;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n@@ -61,25 +62,63 @@\n     /**\n      * Constructs an instance using the specified optimizer.\n      *\n-     * @param optimizer optimizer to use for the fitting\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        super(optimizer);;\n+        super(optimizer);\n     }\n \n+    /**\n+     * Fits a Gaussian function to the observed points.\n+     *\n+     * @param initialGuess First guess values in the following order:\n+     * <ul>\n+     *  <li>Norm</li>\n+     *  <li>Mean</li>\n+     *  <li>Sigma</li>\n+     * </ul>\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n+     */\n+    public double[] fit(double[] initialGuess) {\n+        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n+                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n+\n+                public double value(double x, double[] p) {\n+                    double v = Double.POSITIVE_INFINITY;\n+                    try {\n+                        v = g.value(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+\n+                public double[] gradient(double x, double[] p) {\n+                    double[] v = { Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY };\n+                    try {\n+                        v = g.gradient(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+            };\n+\n+        return fit(f, initialGuess);\n+    }\n \n     /**\n-     * Fits Gaussian function to the observed points.\n-     * It will call the base class\n-     * {@link CurveFitter#fit(\n-     * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\n-     * double[]) fit} method.\n+     * Fits a Gaussian function to the observed points.\n      *\n-     * @return the Gaussian function that best fits the observed points.\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n      */\n     public double[] fit() {\n-        return fit(new Gaussian.Parametric(),\n-                   (new ParameterGuesser(getObservations())).guess());\n+        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n+        return fit(guess);\n     }\n \n     /**\n@@ -112,7 +150,7 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the observed points.\n          *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         public double[] guess() {\n             if (parameters == null) {\n@@ -124,9 +162,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the specified observed points.\n          *\n-         * @param points observed points upon which should base guess\n-         *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @param points Observed points upon which should base guess.\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         private double[] basicGuess(WeightedObservedPoint[] points) {\n             Arrays.sort(points, createWeightedObservedPointComparator());\n@@ -154,9 +190,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Finds index of point in specified points with the largest Y.\n          *\n-         * @param points points to search\n-         *\n-         * @return index in specified points array\n+         * @param points Points to search.\n+         * @return the index in specified points array.\n          */\n         private int findMaxY(WeightedObservedPoint[] points) {\n             int maxYIdx = 0;\n@@ -169,20 +204,18 @@ private int findMaxY(WeightedObservedPoint[] points) {\n         }\n \n         /**\n-         * Interpolates using the specified points to determine X at the specified\n-         * Y.\n+         * Interpolates using the specified points to determine X at the\n+         * specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return value of X at the specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         *  interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the value of X at the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private double interpolateXAtY(WeightedObservedPoint[] points,\n                                        int startIdx, int idxStep, double y)\n@@ -208,18 +241,16 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n          * Gets the two bounding interpolation points from the specified points\n          * suitable for determining X at the specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return array containing two points suitable for determining X at the\n-         *         specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         * interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the array containing two points suitable for determining X at\n+         * the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                    int startIdx, int idxStep, double y)\n@@ -250,13 +280,12 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n         /**\n          * Determines whether a value is between two other values.\n          *\n-         * @param value value to determine whether is between <code>boundary1</code>\n-         *        and <code>boundary2</code>\n-         * @param boundary1 one end of the range\n-         * @param boundary2 other end of the range\n-         *\n-         * @return true if <code>value</code> is between <code>boundary1</code> and\n-         *         <code>boundary2</code> (inclusive); false otherwise\n+         * @param value Value to determine whether is between {@code boundary1}\n+         * and {@code boundary2}.\n+         * @param boundary1 One end of the range.\n+         * @param boundary2 Other end of the range.\n+         * @return {@code true} if {@code value} is between {@code boundary1} and\n+         * {@code boundary2} (inclusive), {@code false} otherwise.\n          */\n         private boolean isBetween(double value, double boundary1, double boundary2) {\n             return (value >= boundary1 && value <= boundary2) ||\n@@ -264,10 +293,10 @@ private boolean isBetween(double value, double boundary1, double boundary2) {\n         }\n \n         /**\n-         * Factory method creating <code>Comparator</code> for comparing\n-         * <code>WeightedObservedPoint</code> instances.\n+         * Factory method creating {@code Comparator} for comparing\n+         * {@code WeightedObservedPoint} instances.\n          *\n-         * @return new <code>Comparator</code> instance\n+         * @return the new {@code Comparator} instance.\n          */\n         private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n             return new Comparator<WeightedObservedPoint>() {\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}