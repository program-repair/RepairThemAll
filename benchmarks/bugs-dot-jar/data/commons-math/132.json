{
    "bug_id": 132,
    "classification": {
        "singleLine": false
    },
    "commit": "c06cc933",
    "failing_tests": [
        "org.apache.commons.math.linear.SingularValueSolverTest"
    ],
    "files": 2,
    "jira_id": "320",
    "linesAdd": 112,
    "linesRem": 130,
    "nb_error": 1,
    "nb_failure": 2,
    "nb_skipped": 0,
    "nb_test": 2124,
    "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\nindex 5f91636e6..bbb205736 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n@@ -24,9 +24,17 @@\n  * Singular Value Decomposition of a real matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p is n,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n  * <p>This interface is similar to the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\ndiff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 0da87ab2a..6003ed677 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -21,12 +21,24 @@\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Calculates the Singular Value Decomposition of a matrix.\n+ * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Note that since this class computes only the compact or truncated SVD and not\n+ * the full SVD, the singular values computed are always positive.\n+ * </p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n@@ -75,13 +87,25 @@\n     /** Cached value of V<sup>T</sup>. */\n     private RealMatrix cachedVt;\n \n+    /**\n+     * Calculates the compact Singular Value Decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link\n+     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n+    }\n+\n     /**\n      * Calculates the Singular Value Decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n+     * @param max maximal number of singular values to compute\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n      */\n-    public SingularValueDecompositionImpl(RealMatrix matrix)\n+    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n         throws InvalidMatrixException {\n \n         m = matrix.getRowDimension();\n@@ -113,10 +137,14 @@ public SingularValueDecompositionImpl(RealMatrix matrix)\n         eigenDecomposition =\n             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                        MathUtils.SAFE_MIN);\n-        singularValues = eigenDecomposition.getRealEigenvalues();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            singularValues[i] = (si < 0) ? 0.0 : Math.sqrt(si);\n+        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n+        int p = Math.min(max, eigenValues.length);\n+        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n+            --p;\n+        }\n+        singularValues = new double[p];\n+        for (int i = 0; i < p; ++i) {\n+            singularValues[i] = Math.sqrt(eigenValues[i]);\n         }\n \n     }\n@@ -127,37 +155,41 @@ public RealMatrix getU()\n \n         if (cachedU == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[m][];\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < n - 1; ++i) {\n-                    // compute B.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n+                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < n; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[n - 1];\n-                for (int j = 0; j < n; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = n; i < m; ++i) {\n-                    iData[i] = new double[n];\n+                for (int i = p; i < m; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedU =\n-                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                cachedU = transformer.getU().multiply(e);\n             }\n \n         }\n@@ -205,37 +237,41 @@ public RealMatrix getV()\n \n         if (cachedV == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                cachedV = transformer.getV().multiply(e);\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[n][];\n+                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < m - 1; ++i) {\n-                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < m; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[m - 1];\n-                for (int j = 0; j < m; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = m; i < n; ++i) {\n-                    iData[i] = new double[m];\n+                for (int i = p; i < n; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedV =\n-                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n             }\n \n         }\n@@ -262,8 +298,9 @@ public RealMatrix getVT()\n     public RealMatrix getCovariance(final double minSingularValue) {\n \n         // get the number of singular values to consider\n+        final int p = singularValues.length;\n         int dimension = 0;\n-        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\n+        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n             ++dimension;\n         }\n \n@@ -273,14 +310,14 @@ public RealMatrix getCovariance(final double minSingularValue) {\n                   minSingularValue, singularValues[0]);\n         }\n \n-        final double[][] data = new double[dimension][n];\n+        final double[][] data = new double[dimension][p];\n         getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             /** {@inheritDoc} */\n             @Override\n             public void visit(final int row, final int column, final double value) {\n                 data[row][column] = value / singularValues[row];\n             }\n-        }, 0, dimension - 1, 0, n - 1);\n+        }, 0, dimension - 1, 0, p - 1);\n \n         RealMatrix jv = new Array2DRowRealMatrix(data, false);\n         return jv.transpose().multiply(jv);\n@@ -317,20 +354,14 @@ public int getRank()\n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n         return new Solver(singularValues, getUT(), getV(),\n-                          getRank() == singularValues.length);\n+                          getRank() == Math.max(m, n));\n     }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n \n-        /** Singular values. */\n-        private final double[] singularValues;\n-\n-        /** U<sup>T</sup> matrix of the decomposition. */\n-        private final RealMatrix uT;\n-\n-        /** V matrix of the decomposition. */\n-        private final RealMatrix v;\n+        /** Pseudo-inverse of the initial matrix. */\n+        private final RealMatrix pseudoInverse;\n \n         /** Singularity indicator. */\n         private boolean nonSingular;\n@@ -344,9 +375,15 @@ public DecompositionSolver getSolver() {\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n                        final boolean nonSingular) {\n-            this.singularValues = singularValues;\n-            this.uT             = uT;\n-            this.v              = v;\n+            double[][] suT      = uT.getData();\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double a      = 1.0 / singularValues[i];\n+                final double[] suTi = suT[i];\n+                for (int j = 0; j < suTi.length; ++j) {\n+                    suTi[j] *= a;\n+                }\n+            }\n+            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n             this.nonSingular = nonSingular;\n         }\n \n@@ -356,27 +393,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public double[] solve(final double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.length != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                        b.length, uT.getColumnDimension());\n-            }\n-\n-            final double[] w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w[i] /= si;\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -385,27 +405,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealVector solve(final RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getDimension() != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                         b.getDimension(), uT.getColumnDimension());\n-            }\n-\n-            final RealVector w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w.setEntry(i, w.getEntry(i) / si);\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -414,31 +417,10 @@ public RealVector solve(final RealVector b)\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a matrix X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealMatrix solve(final RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getRowDimension() != singularValues.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        b.getRowDimension(), b.getColumnDimension(),\n-                        singularValues.length, \"n\");\n-            }\n-\n-            final RealMatrix w = uT.multiply(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si  = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                final double inv = 1.0 / si;\n-                for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    w.multiplyEntry(i, j, inv);\n-                }\n-            }\n-            return v.multiply(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.multiply(b);\n         }\n \n         /**\n@@ -451,17 +433,9 @@ public boolean isNonSingular() {\n \n         /** Get the pseudo-inverse of the decomposed matrix.\n          * @return inverse matrix\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealMatrix getInverse()\n-            throws InvalidMatrixException {\n-\n-            if (!isNonSingular()) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n-\n+        public RealMatrix getInverse() {\n+            return pseudoInverse;\n         }\n \n     }\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}