{
    "bug_id": 22,
    "classification": {
        "singleLine": false
    },
    "commit": "f64b6a90",
    "failing_tests": [
        "org.apache.commons.math3.special.BetaTest"
    ],
    "files": 1,
    "jira_id": "738",
    "linesAdd": 325,
    "linesRem": 24,
    "nb_error": 28,
    "nb_failure": 1,
    "nb_skipped": 4,
    "nb_test": 4261,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex 242079189..6e15fa380 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -16,12 +16,38 @@\n  */\n package org.apache.commons.math3.special;\n \n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.util.ContinuedFraction;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n+ * <p>\n  * This is a utility class that provides computation methods related to the\n  * Beta family of functions.\n+ * </p>\n+ * <p>\n+ * Implementation of {@link #logBeta(double, double)} is based on the\n+ * algorithms described in\n+ * <ul>\n+ * <li><a href=\"http://dx.doi.org/10.1145/22721.23109\">Didonato and Morris\n+ *     (1986)</a>, <em>Computation of the Incomplete Gamma Function Ratios\n+ *     and their Inverse</em>, TOMS 12(4), 377-393,</li>\n+ * <li><a href=\"http://dx.doi.org/10.1145/131766.131776\">Didonato and Morris\n+ *     (1992)</a>, <em>Algorithm 708: Significant Digit Computation of the\n+ *     Incomplete Beta Function Ratios</em>, TOMS 18(3), 360-373,</li>\n+ * </ul>\n+ * and implemented in the\n+ * <a href=\"http://www.dtic.mil/docs/citations/ADA476840\">NSWC Library of Mathematical Functions</a>,\n+ * available\n+ * <a href=\"http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html\">here</a>.\n+ * This library is \"approved for public release\", and the\n+ * <a href=\"http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf\">Copyright guidance</a>\n+ * indicates that unless otherwise stated in the code, all FORTRAN functions in\n+ * this library are license free. Since no such notice appears in the code these\n+ * functions can safely be ported to Commons-Math.\n+ * </p>\n+ *\n  *\n  * @version $Id$\n  */\n@@ -29,6 +55,47 @@\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 1E-14;\n \n+    /** The constant value of \u00bdlog 2\u03c0. */\n+    private static final double HALF_LOG_TWO_PI = .9189385332046727;\n+\n+    /**\n+     * <p>\n+     * The coefficients of the series expansion of the \u0394 function. This function\n+     * is defined as follows\n+     * </p>\n+     * <center>\u0394(x) = log \u0393(x) - (x - 0.5) log a + a - 0.5 log 2\u03c0,</center>\n+     * <p>\n+     * see equation (23) in Didonato and Morris (1992). The series expansion,\n+     * which applies for x \u2265 10, reads\n+     * </p>\n+     * <pre>\n+     *                 14\n+     *                ====\n+     *             1  \\                2 n\n+     *     \u0394(x) = ---  >    d  (10 / x)\n+     *             x  /      n\n+     *                ====\n+     *                n = 0\n+     * <pre>\n+     */\n+    private static final double[] DELTA = {\n+        .833333333333333333333333333333E-01,\n+        -.277777777777777777777777752282E-04,\n+        .793650793650793650791732130419E-07,\n+        -.595238095238095232389839236182E-09,\n+        .841750841750832853294451671990E-11,\n+        -.191752691751854612334149171243E-12,\n+        .641025640510325475730918472625E-14,\n+        -.295506514125338232839867823991E-15,\n+        .179643716359402238723287696452E-16,\n+        -.139228964661627791231203060395E-17,\n+        .133802855014020915603275339093E-18,\n+        -.154246009867966094273710216533E-19,\n+        .197701992980957427278370133333E-20,\n+        -.234065664793997056856992426667E-21,\n+        .171348014966398575409015466667E-22\n+    };\n+\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n@@ -159,17 +226,6 @@ protected double getA(int n, double x) {\n         return ret;\n     }\n \n-    /**\n-     * Returns the natural logarithm of the beta function B(a, b).\n-     *\n-     * @param a Parameter {@code a}.\n-     * @param b Parameter {@code b}.\n-     * @return log(B(a, b)).\n-     */\n-    public static double logBeta(double a, double b) {\n-        return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n-    }\n-\n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n      *\n@@ -181,27 +237,272 @@ public static double logBeta(double a, double b) {\n      *\n      * @param a Parameter {@code a}.\n      * @param b Parameter {@code b}.\n-     * @param epsilon When the absolute value of the nth item in the\n-     * series is less than epsilon the approximation ceases to calculate\n-     * further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete.\n+     * @param epsilon This parameter is ignored.\n+     * @param maxIterations This parameter is ignored.\n      * @return log(B(a, b)).\n+     * @deprecated as of version 3.1, this method is deprecated as the\n+     * computation of the beta function is no longer iterative. This method\n+     * internally calls {@link #logBeta(double, double)}.\n      */\n+    @Deprecated\n     public static double logBeta(double a, double b,\n                                  double epsilon,\n                                  int maxIterations) {\n-        double ret;\n \n-        if (Double.isNaN(a) ||\n-            Double.isNaN(b) ||\n-            a <= 0.0 ||\n-            b <= 0.0) {\n-            ret = Double.NaN;\n+        return logBeta(a, b);\n+    }\n+\n+\n+    /**\n+     * Returns the value of log \u0393(a + b) for 1 \u2264 a, b \u2264 2. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DGSMLN}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(a + b))}.\n+     * @throws OutOfRangeException if {@code a} or {@code b} is lower than\n+     * {@code 1.0} or greater than {@code 2.0}.\n+     */\n+    private static double logGammaSum(final double a, final double b)\n+        throws OutOfRangeException {\n+\n+        if ((a < 1.0) || (a > 2.0)) {\n+            throw new OutOfRangeException(a, 1.0, 2.0);\n+        }\n+        if ((b < 1.0) || (b > 2.0)) {\n+            throw new OutOfRangeException(b, 1.0, 2.0);\n+        }\n+\n+        final double x = (a - 1.0) + (b - 1.0);\n+        if (x <= 0.5) {\n+            return Gamma.logGamma1p(1.0 + x);\n+        } else if (x <= 1.5) {\n+            return Gamma.logGamma1p(x) + FastMath.log1p(x);\n         } else {\n-            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n-                Gamma.logGamma(a + b);\n+            return Gamma.logGamma1p(x - 1.0) + FastMath.log(x * (1.0 + x));\n+        }\n     }\n \n-        return ret;\n+    /**\n+     * Returns the value of log[\u0393(b) / \u0393(a + b)] for a \u2265 0 and b \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DLGDIV}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(b) / Gamma(a + b))}.\n+     * @throws NumberIsTooSmallException if {@code a < 0.0} or {@code b < 10.0}.\n+     */\n+    private static double logGammaMinusLogGammaSum(final double a,\n+                                                   final double b)\n+        throws NumberIsTooSmallException {\n+\n+        if (a < 0.0) {\n+            throw new NumberIsTooSmallException(a, 0.0, true);\n+        }\n+        if (b < 10.0) {\n+            throw new NumberIsTooSmallException(b, 10.0, true);\n+        }\n+\n+        /*\n+         * p = a / (a + b), q = b / (a + b), d = a + b - 0.5\n+         */\n+        final double p;\n+        final double q;\n+        final double d;\n+        final double w;\n+        if (a <= b) {\n+            d = b + (a - 0.5);\n+            w = deltaMinusDeltaSum(a, b);\n+        } else {\n+            d = a + (b - 0.5);\n+            w = deltaMinusDeltaSum(b, a);\n+        }\n+\n+        final double u = d * FastMath.log1p(a / b);\n+        final double v = a * (FastMath.log(b) - 1.0);\n+\n+        return u <= v ? (w - u) - v : (w - v) - u;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(b) - \u0394(a + b), with 0 \u2264 a \u2264 b and b \u2265 10. Based\n+     * on equations (26), (27) and (28) in Didonato and Morris (1992).\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code Delta(b) - Delta(a + b)}\n+     * @throws OutOfRangeException if {@code a < 0} or {@code a > b}\n+     * @throws NumberIsTooSmallException if {@code b < 10}\n+     */\n+    private static double deltaMinusDeltaSum(final double a,\n+                                             final double b)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n+\n+        if ((a < 0) || (a > b)) {\n+            throw new OutOfRangeException(a, 0, b);\n+        }\n+        if (b < 10) {\n+            throw new NumberIsTooSmallException(b, 10, true);\n+        }\n+\n+        final double h = a / b;\n+        final double p = h / (1.0 + h);\n+        final double q = 1.0 / (1.0 + h);\n+        final double q2 = q * q;\n+        /*\n+         * s[i] = 1 + q + ... - q**(2 * i)\n+         */\n+        final double[] s = new double[DELTA.length];\n+        s[0] = 1.0;\n+        for (int i = 1; i < s.length; i++) {\n+            s[i] = 1.0 + (q + q2 * s[i - 1]);\n+        }\n+        /*\n+         * w = Delta(b) - Delta(a + b)\n+         */\n+        final double sqrtT = 10.0 / b;\n+        final double t = sqrtT * sqrtT;\n+        double w = DELTA[DELTA.length - 1] * s[s.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            w = t * w + DELTA[i] * s[i];\n+        }\n+        return w * p / b;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(p) + \u0394(q) - \u0394(p + q), with p, q \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DBCORR}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code Delta(p) + Delta(q) - Delta(p + q)}.\n+     * @throws NumberIsTooSmallException if {@code p < 10.0} or {@code q < 10.0}.\n+     */\n+    private static double sumDeltaMinusDeltaSum(final double p,\n+                                                final double q) {\n+\n+        if (p < 10.0) {\n+            throw new NumberIsTooSmallException(p, 10.0, true);\n+        }\n+        if (q < 10.0) {\n+            throw new NumberIsTooSmallException(q, 10.0, true);\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        final double sqrtT = 10.0 / a;\n+        final double t = sqrtT * sqrtT;\n+        double z = DELTA[DELTA.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            z = t * z + DELTA[i];\n+        }\n+        return z / a + deltaMinusDeltaSum(a, b);\n+    }\n+\n+    /**\n+     * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n+     * {@code DBETLN}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n+     * {@code p <= 0} or {@code q <= 0}.\n+     */\n+    public static final double logBeta(final double p, final double q) {\n+\n+        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        if (a >= 10.0) {\n+            final double w = sumDeltaMinusDeltaSum(a, b);\n+            final double h = a / b;\n+            final double c = h / (1.0 + h);\n+            final double u = -(a - 0.5) * FastMath.log(c);\n+            final double v = b * FastMath.log1p(h);\n+            if (u <= v) {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n+            } else {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n+            }\n+        } else if (a > 2.0) {\n+            if (b > 1000.0) {\n+                final int n = (int) FastMath.floor(a - 1.0);\n+                double prod = 1.0;\n+                double ared = a;\n+                for (int i = 0; i < n; i++) {\n+                    ared -= 1.0;\n+                    prod *= ared / (1.0 + ared / b);\n+                }\n+                return (FastMath.log(prod) - n * FastMath.log(b)) +\n+                        (Gamma.logGamma(ared) +\n+                         logGammaMinusLogGammaSum(ared, b));\n+            } else {\n+                double prod1 = 1.0;\n+                double ared = a;\n+                while (ared > 2.0) {\n+                    ared -= 1.0;\n+                    final double h = ared / b;\n+                    prod1 *= h / (1.0 + h);\n+                }\n+                if (b < 10.0) {\n+                    double prod2 = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod2 *= bred / (ared + bred);\n+                    }\n+                    return FastMath.log(prod1) +\n+                           FastMath.log(prod2) +\n+                           (Gamma.logGamma(ared) +\n+                           (Gamma.logGamma(bred) -\n+                            logGammaSum(ared, bred)));\n+                } else {\n+                    return FastMath.log(prod1) +\n+                           Gamma.logGamma(ared) +\n+                           logGammaMinusLogGammaSum(ared, b);\n+                }\n+            }\n+        } else if (a >= 1.0) {\n+            if (b > 2.0) {\n+                if (b < 10.0) {\n+                    double prod = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod *= bred / (a + bred);\n+                    }\n+                    return FastMath.log(prod) +\n+                           (Gamma.logGamma(a) +\n+                            (Gamma.logGamma(bred) -\n+                             logGammaSum(a, bred)));\n+                } else {\n+                    return Gamma.logGamma(a) +\n+                           logGammaMinusLogGammaSum(a, b);\n+                }\n+            } else {\n+                return Gamma.logGamma(a) +\n+                       Gamma.logGamma(b) -\n+                       logGammaSum(a, b);\n+            }\n+        } else {\n+            if (b >= 10.0) {\n+                return Gamma.logGamma(a) +\n+                       logGammaMinusLogGammaSum(a, b);\n+            } else {\n+                // The following command is the original NSWC implementation.\n+                // return Gamma.logGamma(a) +\n+                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n+                // The following command turns out to be more accurate.\n+                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n+                                    Gamma.gamma(a + b));\n+            }\n+        }\n     }\n }\n",
    "project": "commons-math"
}