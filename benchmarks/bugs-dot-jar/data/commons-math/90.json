{
    "bug_id": 90,
    "classification": {
        "singleLine": false
    },
    "commit": "bfbb156d",
    "failing_tests": [
        "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest"
    ],
    "files": 1,
    "jira_id": "867",
    "linesAdd": 15,
    "linesRem": 114,
    "nb_error": 1,
    "nb_failure": 1,
    "nb_skipped": 4,
    "nb_test": 4157,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 866c8fdf8..388d1dfd4 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -123,13 +123,11 @@\n     private boolean isActiveCMA;\n     /**\n      * Determines how often a new random offspring is generated in case it is\n-     * not feasible / beyond the defined limits, default is 0. Only relevant if\n-     * boundaries != null.\n+     * not feasible / beyond the defined limits, default is 0.\n      */\n     private int checkFeasableCount;\n     /**\n-     * Lower and upper boundaries of the objective variables. boundaries == null\n-     * means no boundaries.\n+     * Lower and upper boundaries of the objective variables.\n      */\n     private double[][] boundaries;\n     /**\n@@ -357,7 +355,7 @@ protected PointValuePair doOptimize() {\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         final FitnessFunction fitfun = new FitnessFunction();\n-        final double[] guess = fitfun.encode(getStartPoint());\n+        final double[] guess = getStartPoint();\n         // number of objective variables/problem dimension\n         dimension = guess.length;\n         initializeCMA(guess);\n@@ -422,7 +420,7 @@ protected PointValuePair doOptimize() {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                            fitfun.repair(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n@@ -506,56 +504,11 @@ private void checkParameters() {\n         final double[] lB = getLowerBound();\n         final double[] uB = getUpperBound();\n \n-        // Checks whether there is at least one finite bound value.\n-        boolean hasFiniteBounds = false;\n-        for (int i = 0; i < lB.length; i++) {\n-            if (!Double.isInfinite(lB[i]) ||\n-                !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n-                break;\n-            }\n-        }\n-        // Checks whether there is at least one infinite bound value.\n-        boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n-            for (int i = 0; i < lB.length; i++) {\n-                if (Double.isInfinite(lB[i]) ||\n-                    Double.isInfinite(uB[i])) {\n-                    hasInfiniteBounds = true;\n-                    break;\n-                }\n-            }\n-\n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n         // Convert API to internal handling of boundaries.\n         boundaries = new double[2][];\n         boundaries[0] = lB;\n         boundaries[1] = uB;\n \n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n-            }\n-        } else {\n-            // Convert API to internal handling of boundaries.\n-            boundaries = null;\n-        }\n-\n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 throw new DimensionMismatchException(inputSigma.length, init.length);\n@@ -564,14 +517,12 @@ private void checkParameters() {\n                 if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n                 }\n-                if (boundaries != null) {\n                 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                     throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                 }\n             }\n         }\n     }\n-    }\n \n     /**\n      * Initialization of the dynamic search parameters\n@@ -585,8 +536,7 @@ private void initializeCMA(double[] guess) {\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n         for (int i = 0; i < guess.length; i++) {\n-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            sigmaArray[i][0] = inputSigma == null ? 0.3 : inputSigma[i];\n         }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n@@ -918,62 +868,20 @@ public FitnessFunction() {\n             isRepairMode = true;\n         }\n \n-        /**\n-         * @param x Original objective variables.\n-         * @return the normalized objective variables.\n-         */\n-        public double[] encode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n-            }\n-            return res;\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables, possibly repaired.\n-         */\n-        public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n-                decode(x);\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables.\n-         */\n-        public double[] decode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n-            }\n-            return res;\n-        }\n-\n         /**\n          * @param point Normalized objective variables.\n          * @return the objective value + penalty for violated bounds.\n          */\n         public double value(final double[] point) {\n             double value;\n-            if (boundaries != null && isRepairMode) {\n+            if (isRepairMode) {\n                 double[] repaired = repair(point);\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(repaired)) +\n+                        .computeObjectiveValue(repaired) +\n                         penalty(point, repaired);\n             } else {\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(point));\n+                        .computeObjectiveValue(point);\n             }\n             return isMinimize ? value : -value;\n         }\n@@ -983,18 +891,11 @@ public double value(final double[] point) {\n          * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n-            if (boundaries == null) {\n-                return true;\n-            }\n-\n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n-\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < boundaries[0][i]) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > boundaries[1][i]) {\n                     return false;\n                 }\n             }\n@@ -1013,12 +914,12 @@ public void setValueRange(double valueRange) {\n          * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n-            double[] repaired = new double[x.length];\n+            final double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n-                    repaired[i] = 0;\n-                } else if (x[i] > 1.0) {\n-                    repaired[i] = 1.0;\n+                if (x[i] < boundaries[0][i]) {\n+                    repaired[i] = boundaries[0][i];\n+                } else if (x[i] > boundaries[1][i]) {\n+                    repaired[i] = boundaries[1][i];\n                 } else {\n                     repaired[i] = x[i];\n                 }\n",
    "project": "commons-math"
}