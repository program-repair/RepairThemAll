{
    "bug_id": 69,
    "classification": {
        "singleLine": false
    },
    "commit": "495f04bc",
    "failing_tests": [
        "org.apache.commons.math.util.MathUtilsTest"
    ],
    "files": 1,
    "jira_id": "370",
    "linesAdd": 10,
    "linesRem": 63,
    "nb_error": 0,
    "nb_failure": 1,
    "nb_skipped": 0,
    "nb_test": 2272,
    "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 887dc66a2..ab0fe3358 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -407,20 +407,14 @@ public static double cosh(double x) {\n \n     /**\n      * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) this method}.\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n@@ -524,12 +518,6 @@ public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n@@ -1101,29 +1089,6 @@ public static long mulAndCheck(long a, long b) {\n         return ret;\n     }\n \n-    /**\n-     * Get the next machine representable number after a number, moving\n-     * in the direction of another number.\n-     * <p>\n-     * If <code>direction</code> is greater than or equal to<code>d</code>,\n-     * the smallest machine representable number strictly greater than\n-     * <code>d</code> is returned; otherwise the largest representable number\n-     * strictly less than <code>d</code> is returned.</p>\n-     * <p>\n-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     *\n-     * @param d base number\n-     * @param direction (the only important thing is whether\n-     * direction is greater or smaller than d)\n-     * @return the next machine representable number in the specified direction\n-     * @since 1.2\n-     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n-     */\n-    @Deprecated\n-    public static double nextAfter(double d, double direction) {\n-        return FastMath.nextAfter(d, direction);\n-    }\n-\n     /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n@@ -1318,23 +1283,23 @@ private static double roundUnscaled(double unscaled, double sign,\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1361,7 +1326,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1376,7 +1341,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n@@ -1904,24 +1869,6 @@ public static void checkOrder(double[] val) {\n         checkOrder(val, OrderDirection.INCREASING, true);\n     }\n \n-    /**\n-     * Checks that the given array is sorted.\n-     *\n-     * @param val Values\n-     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n-     * @param strict Whether the order should be strict\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\n-     * checkOrder} method). To be removed in 3.0.\n-     */\n-    public static void checkOrder(double[] val, int dir, boolean strict) {\n-        if (dir > 0) {\n-            checkOrder(val, OrderDirection.INCREASING, strict);\n-        } else {\n-            checkOrder(val, OrderDirection.DECREASING, strict);\n-        }\n-    }\n-\n     /**\n      * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n      * Translation of the minpack enorm subroutine.\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": true
}