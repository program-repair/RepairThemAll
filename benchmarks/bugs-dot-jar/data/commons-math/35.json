{
    "bug_id": 35,
    "classification": {
        "singleLine": false
    },
    "commit": "19c1c3bb",
    "failing_tests": [
        "org.apache.commons.math3.geometry.enclosing.WelzlEncloser3DTest",
        "org.apache.commons.math3.geometry.euclidean.threed.SphereGeneratorTest"
    ],
    "files": 3,
    "jira_id": "1096",
    "linesAdd": 73,
    "linesRem": 72,
    "nb_error": 1,
    "nb_failure": 1,
    "nb_skipped": 5,
    "nb_test": 5671,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex 1bacb2549..12a645f43 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -100,7 +101,7 @@ public WelzlEncloser(final double tolerance, final SupportBallGenerator<S, P> ge\n             EnclosingBall<S, P> savedBall = ball;\n             ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n-                // TODO: fix this, it should never happen but it does!\n+                // this should never happen\n                 throw new MathInternalError();\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\nindex 03e445089..f5a6b7c95 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n@@ -19,12 +19,13 @@\n import java.util.Arrays;\n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.DiskGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -88,24 +89,39 @@\n                         //      z_0 = +m_14 / (2 m_11)\n                         // Note that the minors m_11, m_12, m_13 and m_14 all have the last column\n                         // filled with 1.0, hence simplifying the computation\n-                        final double[] c1 = new double[] {\n-                            vA.getNormSq(), vB.getNormSq(), vC.getNormSq(), vD.getNormSq()\n+                        final BigFraction[] c2 = new BigFraction[] {\n+                            new BigFraction(vA.getX()), new BigFraction(vB.getX()),\n+                            new BigFraction(vC.getX()), new BigFraction(vD.getX())\n                         };\n-                        final double[] c2 = new double[] {\n-                            vA.getX(), vB.getX(), vC.getX(), vD.getX()\n+                        final BigFraction[] c3 = new BigFraction[] {\n+                            new BigFraction(vA.getY()), new BigFraction(vB.getY()),\n+                            new BigFraction(vC.getY()), new BigFraction(vD.getY())\n                         };\n-                        final double[] c3 = new double[] {\n-                            vA.getY(), vB.getY(), vC.getY(), vD.getY()\n+                        final BigFraction[] c4 = new BigFraction[] {\n+                            new BigFraction(vA.getZ()), new BigFraction(vB.getZ()),\n+                            new BigFraction(vC.getZ()), new BigFraction(vD.getZ())\n                         };\n-                        final double[] c4 = new double[] {\n-                            vA.getZ(), vB.getZ(), vC.getZ(), vD.getZ()\n+                        final BigFraction[] c1 = new BigFraction[] {\n+                            c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])).add(c4[0].multiply(c4[0])),\n+                            c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])).add(c4[1].multiply(c4[1])),\n+                            c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2])).add(c4[2].multiply(c4[2])),\n+                            c2[3].multiply(c2[3]).add(c3[3].multiply(c3[3])).add(c4[3].multiply(c4[3]))\n                         };\n-                        final double m11 = minor(c2, c3, c4);\n-                        final double m12 = minor(c1, c3, c4);\n-                        final double m13 = minor(c1, c2, c4);\n-                        final double m14 = minor(c1, c2, c3);\n-                        final Vector3D center = new Vector3D(0.5 * m12 / m11, -0.5 * m13 / m11, 0.5 * m14 / m11);\n-                        return new EnclosingBall<Euclidean3D, Vector3D>(center, center.distance(vA),\n+                        final BigFraction twoM11  = minor(c2, c3, c4).multiply(2);\n+                        final BigFraction m12     = minor(c1, c3, c4);\n+                        final BigFraction m13     = minor(c1, c2, c4);\n+                        final BigFraction m14     = minor(c1, c2, c3);\n+                        final BigFraction centerX = m12.divide(twoM11);\n+                        final BigFraction centerY = m13.divide(twoM11).negate();\n+                        final BigFraction centerZ = m14.divide(twoM11);\n+                        final BigFraction dx      = c2[0].subtract(centerX);\n+                        final BigFraction dy      = c3[0].subtract(centerY);\n+                        final BigFraction dz      = c4[0].subtract(centerZ);\n+                        final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+                        return new EnclosingBall<Euclidean3D, Vector3D>(new Vector3D(centerX.doubleValue(),\n+                                                                                     centerY.doubleValue(),\n+                                                                                     centerZ.doubleValue()),\n+                                                                        FastMath.sqrt(r2.doubleValue()),\n                                                                         vA, vB, vC, vD);\n                     }\n                 }\n@@ -114,41 +130,24 @@\n     }\n \n     /** Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n      * @param c3 third column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2, final double[] c3) {\n-        final double m01 = c2[0] * c3[1];\n-        final double m02 = c2[0] * c3[2];\n-        final double m03 = c2[0] * c3[3];\n-        final double m10 = c2[1] * c3[0];\n-        final double m12 = c2[1] * c3[2];\n-        final double m13 = c2[1] * c3[3];\n-        final double m20 = c2[2] * c3[0];\n-        final double m21 = c2[2] * c3[1];\n-        final double m23 = c2[2] * c3[3];\n-        final double m30 = c2[3] * c3[0];\n-        final double m31 = c2[3] * c3[1];\n-        final double m32 = c2[3] * c3[2];\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2],\n-                                                c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2],\n-                                                c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1],\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                m13, m32, m21, m23, m12, m31,\n-                                                m23, m02, m30, m20, m32, m03,\n-                                                m03, m31, m10, m13, m01, m30,\n-                                                m12, m01, m20, m10, m21, m02\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2, final BigFraction[] c3) {\n+        return      c2[0].multiply(c3[1]).multiply(c1[2].subtract(c1[3])).\n+                add(c2[0].multiply(c3[2]).multiply(c1[3].subtract(c1[1]))).\n+                add(c2[0].multiply(c3[3]).multiply(c1[1].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[0]).multiply(c1[3].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[2]).multiply(c1[0].subtract(c1[3]))).\n+                add(c2[1].multiply(c3[3]).multiply(c1[2].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[0]).multiply(c1[1].subtract(c1[3]))).\n+                add(c2[2].multiply(c3[1]).multiply(c1[3].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[3]).multiply(c1[0].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[0]).multiply(c1[2].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[1]).multiply(c1[0].subtract(c1[2]))).\n+                add(c2[3].multiply(c3[2]).multiply(c1[1].subtract(c1[0])));\n     }\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\nindex 514df1458..d06c013cd 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n@@ -18,9 +18,10 @@\n \n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -66,42 +67,43 @@\n                     //      y_0 = -m_13 / (2 m_11)\n                     // Note that the minors m_11, m_12 and m_13 all have the last column\n                     // filled with 1.0, hence simplifying the computation\n-                    final double[] c1 = new double[] {\n-                        vA.getNormSq(), vB.getNormSq(), vC.getNormSq()\n+                    final BigFraction[] c2 = new BigFraction[] {\n+                        new BigFraction(vA.getX()), new BigFraction(vB.getX()), new BigFraction(vC.getX())\n                     };\n-                    final double[] c2 = new double[] {\n-                        vA.getX(), vB.getX(), vC.getX()\n+                    final BigFraction[] c3 = new BigFraction[] {\n+                        new BigFraction(vA.getY()), new BigFraction(vB.getY()), new BigFraction(vC.getY())\n                     };\n-                    final double[] c3 = new double[] {\n-                        vA.getY(), vB.getY(), vC.getY()\n+                    final BigFraction[] c1 = new BigFraction[] {\n+                        c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])),\n+                        c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])),\n+                        c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2]))\n                     };\n-                    final double m11 = minor(c2, c3);\n-                    final double m12 = minor(c1, c3);\n-                    final double m13 = minor(c1, c2);\n-                    final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);\n-                    return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\n+                    final BigFraction twoM11  = minor(c2, c3).multiply(2);\n+                    final BigFraction m12     = minor(c1, c3);\n+                    final BigFraction m13     = minor(c1, c2);\n+                    final BigFraction centerX = m12.divide(twoM11);\n+                    final BigFraction centerY = m13.divide(twoM11).negate();\n+                    final BigFraction dx      = c2[0].subtract(centerX);\n+                    final BigFraction dy      = c3[0].subtract(centerY);\n+                    final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy));\n+                    return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(centerX.doubleValue(),\n+                                                                                 centerY.doubleValue()),\n+                                                                    FastMath.sqrt(r2.doubleValue()),\n+                                                                    vA, vB, vC);\n                 }\n             }\n         }\n     }\n \n     /** Compute a dimension 3 minor, when 3<sup>d</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2) {\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                c2[1], c2[0], c2[2],  c2[1],  c2[2],  c2[0]\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2) {\n+        return      c2[0].multiply(c1[2].subtract(c1[1])).\n+                add(c2[1].multiply(c1[0].subtract(c1[2]))).\n+                add(c2[2].multiply(c1[1].subtract(c1[0])));\n     }\n \n }\n",
    "project": "commons-math",
    "buggy_compile_success": true,
    "buggy_test_success": false,
    "fixed_compile_success": true,
    "fixed_test_success": false
}