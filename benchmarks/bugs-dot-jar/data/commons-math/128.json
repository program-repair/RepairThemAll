{
    "bug_id": 128,
    "classification": {
        "singleLine": false
    },
    "commit": "ad252a8c",
    "failing_tests": [
        "org.apache.commons.math3.linear.SchurTransformerTest",
        "org.apache.commons.math3.linear.EigenDecompositionTest"
    ],
    "files": 1,
    "jira_id": "848",
    "linesAdd": 88,
    "linesRem": 84,
    "nb_error": 1,
    "nb_failure": 1,
    "nb_skipped": 4,
    "nb_test": 4156,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\nindex 584505de6..a2ea88ee4 100644\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n@@ -140,69 +140,66 @@ private void transform() {\n \n         // Outer loop over eigenvalue index\n         int iteration = 0;\n-        int idx = n - 1;\n-        while (idx >= 0) {\n+        int iu = n - 1;\n+        while (iu >= 0) {\n \n             // Look for single small sub-diagonal element\n-            final int l = findSmallSubDiagonalElement(idx, norm);\n+            final int il = findSmallSubDiagonalElement(iu, norm);\n \n             // Check for convergence\n-            if (l == idx) {\n+            if (il == iu) {\n                 // One root found\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                idx--;\n+                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n+                iu--;\n                 iteration = 0;\n-            } else if (l == idx - 1) {\n+            } else if (il == iu - 1) {\n                 // Two roots found\n-                shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n-                double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n-                double q = p * p + shift.w;\n-                double z = FastMath.sqrt(FastMath.abs(q));\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n-                shift.x = matrixT[idx][idx];\n+                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n+                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n+                matrixT[iu][iu] += shift.exShift;\n+                matrixT[iu - 1][iu - 1] += shift.exShift;\n \n                 if (q >= 0) {\n+                    double z = FastMath.sqrt(FastMath.abs(q));\n                     if (p >= 0) {\n                         z = p + z;\n                     } else {\n                         z = p - z;\n                     }\n-                    shift.x = matrixT[idx][idx - 1];\n-                    double s = FastMath.abs(shift.x) + FastMath.abs(z);\n-                    p = shift.x / s;\n+                    final double x = matrixT[iu][iu - 1];\n+                    final double s = FastMath.abs(x) + FastMath.abs(z);\n+                    p = x / s;\n                     q = z / s;\n-                    double r = FastMath.sqrt(p * p + q * q);\n+                    final double r = FastMath.sqrt(p * p + q * q);\n                     p = p / r;\n                     q = q / r;\n \n                     // Row modification\n-                    for (int j = idx - 1; j < n; j++) {\n-                        z = matrixT[idx - 1][j];\n-                        matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n-                        matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n+                    for (int j = iu - 1; j < n; j++) {\n+                        z = matrixT[iu - 1][j];\n+                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n+                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                     }\n \n                     // Column modification\n-                    for (int i = 0; i <= idx; i++) {\n-                        z = matrixT[i][idx - 1];\n-                        matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n-                        matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n+                    for (int i = 0; i <= iu; i++) {\n+                        z = matrixT[i][iu - 1];\n+                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n+                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                     }\n \n                     // Accumulate transformations\n                     for (int i = 0; i <= n - 1; i++) {\n-                        z = matrixP[i][idx - 1];\n-                        matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n-                        matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n+                        z = matrixP[i][iu - 1];\n+                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n+                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n                     }\n                 }\n-                idx -= 2;\n+                iu -= 2;\n                 iteration = 0;\n             } else {\n                 // No convergence yet\n-\n-                computeShift(l, idx, iteration, shift);\n+                computeShift(il, iu, iteration, shift);\n \n                 // stop transformation after too many iterations\n                 if (++iteration > MAX_ITERATIONS) {\n@@ -210,43 +207,11 @@ private void transform() {\n                                                         MAX_ITERATIONS);\n                 }\n \n-                // Look for two consecutive small sub-diagonal elements\n-                int m = idx - 2;\n-\n                 // the initial houseHolder vector for the QR step\n                 final double[] hVec = new double[3];\n \n-                while (m >= l) {\n-                    double z = matrixT[m][m];\n-                    hVec[2] = shift.x - z;\n-                    double s = shift.y - z;\n-                    hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n-                    hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n-                    hVec[2] = matrixT[m + 2][m + 1];\n-                    s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n-\n-                    if (m == l) {\n-                        break;\n-                    }\n-\n-                    for (int i = 0; i < hVec.length; i++) {\n-                        hVec[i] /= s;\n-                    }\n-\n-                    final double lhs = FastMath.abs(matrixT[m][m - 1]) *\n-                            (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n-\n-                    final double rhs = FastMath.abs(hVec[0]) *\n-                            (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) +\n-                             FastMath.abs(matrixT[m + 1][m + 1]));\n-\n-                    if (lhs < epsilon * rhs) {\n-                        break;\n-                    }\n-                    m--;\n-                }\n-\n-                performDoubleQRStep(l, m, idx, shift, hVec);\n+                final int im = initQRStep(il, iu, shift, hVec);\n+                performDoubleQRStep(il, im, iu, shift, hVec);\n             }\n         }\n     }\n@@ -278,7 +243,7 @@ private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n         int l = startIdx;\n         while (l > 0) {\n             double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n-            if (Precision.equals(s, 0.0, epsilon)) {\n+            if (s == 0.0) {\n                 s = norm;\n             }\n             if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n@@ -312,8 +277,9 @@ private void computeShift(final int l, final int idx, final int iteration, final\n             for (int i = 0; i <= idx; i++) {\n                 matrixT[i][i] -= shift.x;\n             }\n-            double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n-            shift.x = shift.y = 0.75 * s;\n+            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n+            shift.x = 0.75 * s;\n+            shift.y = 0.75 * s;\n             shift.w = -0.4375 * s * s;\n         }\n \n@@ -321,7 +287,7 @@ private void computeShift(final int l, final int idx, final int iteration, final\n         if (iteration == 30) {\n             double s = (shift.y - shift.x) / 2.0;\n             s = s * s + shift.w;\n-            if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\n+            if (s > 0.0) {\n                 s = FastMath.sqrt(s);\n                 if (shift.y < shift.x) {\n                     s = -s;\n@@ -336,16 +302,54 @@ private void computeShift(final int l, final int idx, final int iteration, final\n         }\n     }\n \n+    /**\n+     * Initialize the householder vectors for the QR step.\n+     *\n+     * @param il the index of the small sub-diagonal element\n+     * @param iu the current eigenvalue index\n+     * @param shift shift information holder\n+     * @param hVec the initial houseHolder vector\n+     * @return the start index for the QR step\n+     */\n+    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {\n+        // Look for two consecutive small sub-diagonal elements\n+        int im = iu - 2;\n+        while (im >= il) {\n+            final double z = matrixT[im][im];\n+            final double r = shift.x - z;\n+            double s = shift.y - z;\n+            hVec[0] = (r * s - shift.w) / matrixT[im + 1][im] + matrixT[im][im + 1];\n+            hVec[1] = matrixT[im + 1][im + 1] - z - r - s;\n+            hVec[2] = matrixT[im + 2][im + 1];\n+\n+            if (im == il) {\n+                break;\n+            }\n+\n+            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n+            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n+                                                        FastMath.abs(z) +\n+                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n+\n+            if (lhs < epsilon * rhs) {\n+                break;\n+            }\n+            im--;\n+        }\n+\n+        return im;\n+    }\n+\n     /**\n      * Perform a double QR step involving rows l:idx and columns m:n\n      *\n-     * @param l the index of the small sub-diagonal element\n-     * @param m the start index for the QR step\n-     * @param idx the current eigenvalue index\n+     * @param il the index of the small sub-diagonal element\n+     * @param im the start index for the QR step\n+     * @param iu the current eigenvalue index\n      * @param shift shift information holder\n      * @param hVec the initial houseHolder vector\n      */\n-    private void performDoubleQRStep(final int l, final int m, final int idx,\n+    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                      final ShiftInfo shift, final double[] hVec) {\n \n         final int n = matrixT.length;\n@@ -353,9 +357,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         double q = hVec[1];\n         double r = hVec[2];\n \n-        for (int k = m; k <= idx - 1; k++) {\n-            boolean notlast = k != idx - 1;\n-            if (k != m) {\n+        for (int k = im; k <= iu - 1; k++) {\n+            boolean notlast = k != (iu - 1);\n+            if (k != im) {\n                 p = matrixT[k][k - 1];\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n@@ -366,17 +370,17 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                     r = r / shift.x;\n                 }\n             }\n-            if (Precision.equals(shift.x, 0.0, epsilon)) {\n+            if (shift.x == 0.0) {\n                 break;\n             }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n             }\n-            if (!Precision.equals(s, 0.0, epsilon)) {\n-                if (k != m) {\n+            if (s != 0.0) {\n+                if (k != im) {\n                     matrixT[k][k - 1] = -s * shift.x;\n-                } else if (l != m) {\n+                } else if (il != im) {\n                     matrixT[k][k - 1] = -matrixT[k][k - 1];\n                 }\n                 p = p + s;\n@@ -398,7 +402,7 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                 }\n \n                 // Column modification\n-                for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n+                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                     p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                     if (notlast) {\n                         p = p + z * matrixT[i][k + 2];\n@@ -423,9 +427,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         }  // k loop\n \n         // clean up pollution due to round-off errors\n-        for (int i = m+2; i <= idx; i++) {\n+        for (int i = im + 2; i <= iu; i++) {\n             matrixT[i][i-2] = 0.0;\n-            if (i > m+2) {\n+            if (i > im + 2) {\n                 matrixT[i][i-3] = 0.0;\n             }\n         }\n",
    "project": "commons-math"
}