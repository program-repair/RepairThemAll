{
    "bug_id": 126,
    "classification": {
        "singleLine": false
    },
    "commit": "4080feff",
    "failing_tests": [
        "org.apache.commons.math3.ml.neuralnet.sofm.KohonenUpdateActionTest",
        "org.apache.commons.math3.geometry.euclidean.twod.hull.AklToussaintHeuristicTest",
        "org.apache.commons.math3.geometry.euclidean.twod.hull.MonotoneChainTest"
    ],
    "files": 2,
    "jira_id": "1148",
    "linesAdd": 16,
    "linesRem": 10,
    "nb_error": 2,
    "nb_failure": 1,
    "nb_skipped": 3,
    "nb_test": 6081,
    "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\nindex 1e0eec386..5d9734b3b 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n@@ -28,8 +28,8 @@\n import org.apache.commons.math3.geometry.hull.ConvexHull;\n import org.apache.commons.math3.geometry.partitioning.Region;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n-import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * This class represents a convex hull in an two-dimensional euclidean space.\n@@ -62,12 +62,14 @@\n     public ConvexHull2D(final Vector2D[] vertices, final double tolerance)\n         throws MathIllegalArgumentException {\n \n+        // assign tolerance as it will be used by the isConvex method\n+        this.tolerance = tolerance;\n+\n         if (!isConvex(vertices)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NOT_CONVEX);\n         }\n \n         this.vertices = vertices.clone();\n-        this.tolerance = tolerance;\n     }\n \n     /**\n@@ -80,7 +82,7 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             return true;\n         }\n \n-        double sign = 0.0;\n+        int sign = 0;\n         for (int i = 0; i < hullVertices.length; i++) {\n             final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];\n             final Vector2D p2 = hullVertices[i];\n@@ -89,14 +91,14 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             final Vector2D d1 = p2.subtract(p1);\n             final Vector2D d2 = p3.subtract(p2);\n \n-            final double cross = FastMath.signum(MathArrays.linearCombination( d1.getX(), d2.getY(),\n-                                                                              -d1.getY(), d2.getX()));\n+            final double crossProduct = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());\n+            final int cmp = Precision.compareTo(crossProduct, 0.0, tolerance);\n             // in case of collinear points the cross product will be zero\n-            if (cross != 0.0) {\n-                if (sign != 0.0 && cross != sign) {\n+            if (cmp != 0.0) {\n+                if (sign != 0.0 && cmp != sign) {\n                     return false;\n                 }\n-                sign = cross;\n+                sign = cmp;\n             }\n         }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\nindex 6e56fc634..a811ddace 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n@@ -25,6 +25,7 @@\n import org.apache.commons.math3.geometry.euclidean.twod.Line;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * Implements Andrew's monotone chain method to generate the convex hull of a finite set of\n@@ -80,9 +81,12 @@ public MonotoneChain(final boolean includeCollinearPoints, final double toleranc\n         // sort the points in increasing order on the x-axis\n         Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {\n             public int compare(final Vector2D o1, final Vector2D o2) {\n-                final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\n+                final double tolerance = getTolerance();\n+                // need to take the tolerance value into account, otherwise collinear points\n+                // will not be handled correctly when building the upper/lower hull\n+                final int diff = Precision.compareTo(o1.getX(), o2.getX(), tolerance);\n                 if (diff == 0) {\n-                    return (int) FastMath.signum(o1.getY() - o2.getY());\n+                    return Precision.compareTo(o1.getY(), o2.getY(), tolerance);\n                 } else {\n                     return diff;\n                 }\n",
    "project": "commons-math"
}